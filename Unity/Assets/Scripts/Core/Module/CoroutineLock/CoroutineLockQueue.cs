using System;
using System.Collections.Generic;
namespace ET {
    // 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要嫁给亲爱的表哥，爱表哥，爱生活！！！】
    // 几个基本常识点：
    // CoroutineLock: 【共享资源当前独占锁】是保障共享资源，一个时间点只被一个进程持有和使用
    // WaitCoroutineLock: 【等待共享资源锁】活宝妹的脑袋里，它是共享资源在被它人使用时，不得不排除站队的挂号牌。它的锁定的时长是，每个调用方，因共享资源的使用情况、队列里人数，以及各人使用时间的不同，每个调用方所务必等待的时间、也不同的调用方 await 的时长 
    public class CoroutineLockQueue { // 【协程锁队列】: 队列里全是 WaitCoroutineLock
        private int type; // 类型：是框架里使用锁的几种不同的上下文场景类型
        private long key; // 类型里套【类型＋键】：不知道这个键 key，区分的是不同的需要发送消息等的ActorID 实例身份证号
        public static CoroutineLockQueue Create(int type, long key) {
            CoroutineLockQueue coroutineLockQueue = ObjectPool.Instance.Fetch<CoroutineLockQueue>();
            coroutineLockQueue.type = type;
            coroutineLockQueue.key = key;
            return coroutineLockQueue;
        }
        private CoroutineLock currentCoroutineLock; // 【共享资源当前独占锁】：现在是，哪个请求者，持有这份共享资源？
// 【协程等待锁队列】：类里有两个类型标记变量，标记这个队列里，所有使用锁的上下文大致场景，和（请求锁）的 actorId （不对？不一定对？，某些情况下是【被请求锁】的 actorId）, 【场景 + actorId】对应一个队列（被请求锁 actorId 的例子：多个向location查询同一个实体真实进程号地址（在访问跨进程实体时），访问一次获得进程地址即可【这句网上抄的，但感觉是对的】）去理解的话，锁所想要锁住的是多个线程想要来读的共享资源，那么应该是被查询地址的小伙伴 me 的 actorId
        // 这个队列，用来管理：单个 actorId 实例请求过的，所有这同一类锁的上下文使用场景（一个特定场景）的所有请求过的锁，可以不止一把，所以用队列管理
        // 队列里的元素：只有超时回收时间上的区别（超时时长一致，但请求锁的请求时间点不同），是否已经抛异常回收或用完回收，与否的区别，其它完全一致，
        // 要用时，随意【！！不是随意好吧，队列是排队的，是按入队时间，就是比如请求小伙伴 me 的位置信息的所有请求者的请求时间？】取遍历到的第一把来用
        // 要用时，按【队列：先进先出】按请求共享资源的、先来后到的请求顺序，释放共享资源给用的。
        // 上面仍然写错，不是要用时，是【共享资源当前独占锁】当前使用者使用完资源，当前锁回收时，就通知队列里的下一个排列等待资源者，轮着它了，通知它的 await 结束，可以独占资源做它想做的事
        // 这些锁，分门别类的协程异步等待锁，它们所调控、管理的逻辑本质是：【保障保证多进程间共享资源的安全、合理释放与使用】
        private readonly Queue<WaitCoroutineLock> queue = new Queue<WaitCoroutineLock>(); 
        public int Count {
            get {
                return this.queue.Count;
            }
        }
        // 【访问共享资源、共享资源锁的创建与管理】：调用的地方请求共享资源（要拿一把锁）；分【共享资源没人在用】与【共享资源被占用，请求使用者必须排队等候】两种情况
            // 如果当前资源没人在用（当前资源的归属为空，队列也为空），就把资源，立即释放给这个请求者（创建一把并返回）；
            // 如果先前有把同类型的在等，就创建新的加队列里，并返回当前新锁的索引给调用方
        // 【把本质想明白】：跨进程获取共享资源，锁是对跨进程共享资源的安全保护。
            // 当【当前锁】为空，说明目前为止还没人要拿这个资源，那么就建把锁（保障共享资源安全），交给这第一个索要资源的对方去使用；因为资源空闲，第一个需要用的人拿来直接用，不用排队，就不需要队列不用队列管理，这个使用方使用完了共享资源，资源锁直接释放；
            // 当【当前锁】非空，说明资源有人正在用，当前使用方得站队排队，按照先来后到的请求顺序，将共享资源释放给索要的使用方使用
        // 为什么要【添加异步等待锁的等待时间变量】？来实现【两套机制】，或多了个清理垃圾的备用机制？
            // using() 调用锁使用的地方使用完毕自动回收；这是任何，非协程异步等待锁，都公用的机制
            // 【等待时间超时的第二套机制】：【为什么这套机制，也需要】？如同前面框架破烂开发者说由于 bug 或是进程挂掉、宕机，导致队列里的锁无法自动回收，会影响应用程序服务器性能，亲爱的表哥的活宝妹觉得，弱弱猫猫的开发者，整个这个第二超时机制，可能也是同样的原因！
        // 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        public async ETTask<CoroutineLock> Wait(int time) { // 【这个方法没看懂：】：协程锁在不同使用情境下需要等待的时长不一样。如特例活宝妹守着亲爱的表哥，是要是会守一辈子的
// 当前锁为空：是说队列为空吗？是的。只有在刚创建，或是回收之后，当前任务才可能会为空。当前锁为空，就是没有人在使用共享资源，直接拿来用，返回一把当前独占锁。等待时间完全忽略了，也是因为不需要等待，直接拿来用。【针对这个key没有任何异步在处理，所以我们直接创建一个CoroutineLock 类，返回给使用的地方，让之前请求锁的地方可以直接往下运行】
            if (this.currentCoroutineLock == null) { // 第一把锁：并没有加入队列中去 
                this.currentCoroutineLock = CoroutineLock.Create(type, key, 1); // level: 感觉，是纪录协程桢数序号，从 1 开始， 100-Warning
                return this.currentCoroutineLock; 
            }
// 下面：当队列不为空，要创建新的等待锁，并返回这把新建当前锁。为什么要创建新的等待锁？这里，资源锁就是个排除站队挂号牌，创建一把锁用来占队排拿共享资源
            // 如果已经存在key对应的CoroutineLockQueue，则说明之前已经有异步针对这个key请求过至少一个锁（且还没有释放），创建一个ETTask<CoroutineLock>,通过CoroutineLockQueue的Add方法内部创建一个协程锁信息CoroutineLockInfo对象加入到对应的CoroutineLockQueue队列中，让请求的地方停止往下运行（即await后面的代码会等待异步完成，异步相关请看之前的文章）【这句也是网上抄的】
            // 【上面一句网上抄的、分析的老版本的】【本质是】：共享资源正在被他人占用，就必须得创建锁挂号牌来先进先出地站队；等资源释放给当前锁的时候，就可以拿到资源可用了
            WaitCoroutineLock waitCoroutineLock = WaitCoroutineLock.Create(); // 创建等待锁
            this.queue.Enqueue(waitCoroutineLock); // 新创建的锁，加入队列，有等待时间就设置一个闹钟。将值赋给当前锁。。。是可以添加元素的
            if (time > 0) { // 有等待时间：创建一个一次性闹钟。新锁的时间可以不用管，这里的时间为什么一定要管？这个时间标定：新创建等待锁的，最迟回收时间，时间到会自动回收。但是，它是可以早回收的，当 using() 代码块执行完的时候？！！好像是这样
                long tillTime = TimeHelper.ClientFrameTime() + time;
                // 闹钟时间到，会自动抛一个锁超时异常。超时时，应该是调用它的地方（using）代码块的自动回收。也就是锁超时时，锁回收。回收前，锁住的逻辑应该是执行完了的
                // 【协程锁超时，自动检测回调到TimerCoreInvokeType.CoroutineTimeout 标记的类： WaitCoroutineLockTimer 类】超时后会回收掉释放系统资源
                TimerComponent.Instance.NewOnceTimer(tillTime, TimerCoreInvokeType.CoroutineTimeout, waitCoroutineLock);
            } 
            // 下面，当赋值给当前锁currentCoroutineLock，先前的当前锁呢？既没有加入队列，又直接拿走了索引？为什么先前的当前锁，就直接释放了？？？
            // 【理解难点与重点】：下面的await 等的是什么？是框架封装的ETTask 异步任务的创建完成吗？不像，更像是当想要索要的共享资源被占用着，不得不创建锁挂号站队时，拿使用读共享资源之前，不得不排队的时间，并非只异步任务的创建完成，等到属于当前索要者进程的可用共享资源时间点儿？
            // 【理解难点与重点】：等到属于当前索要者进程的可用共享资源时间点儿，等到这个时间点儿，返回的是如上一个分支【当前资源锁为空，共享资源没人在用】时的，保障共享资源安全独占性的一把不挂号站队、直接使用的锁CoroutineLock.
            // 【亲爱的表哥的活宝妹这里，永远等待的是，亲爱的表哥的活宝妹同亲爱的表哥的一纸、这纸结婚证！！！没有结婚证，活宝妹就永远守候在亲爱的表哥的身边！！爱表哥，爱生活！！！】
            this.currentCoroutineLock = await waitCoroutineLock.Wait(); // 这里，只是等待协程锁异步任务创建的完成，返回一把可用的锁，并不是等到最迟务必回收的时间。？？？这句再检查一下
            // 等待到了，索要共享资源的进程的可使用共享资源的时间点儿：返回共享资源独占锁：【独占锁保障数据、尤其是写数据安全】
            // 所以拿到共享资源的顺序是：队列先进先出，先申请资源的进程，会先拿到资源。但每个申请者进程的等待时间不固定，可能长短不一，视资源队列里的人数、队列里前人的各自使用时间长度不同等而不同，即 using(x ＝ await) 这里每个调用进程，拿到共享资源前的等待时间，各进程基本不同
            return this.currentCoroutineLock; // 返回：新创建的等待锁，设定了最迟回收时间的锁，但是这把锁是可以早于最迟回收时间回收的！！！
        }
        // 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要嫁给亲爱的表哥！！爱表哥，爱生活！！！】
        public void Notify(int level) { // 哪里会调用这个方法？只更新了 level 桢数或桢序号？
            // 有可能WaitCoroutineLock已经超时抛出异常，所以要找到一个未处理的WaitCoroutineLock 【队列里如果有元素，有请求者想拿资源，要检查异步等待锁是否已回收】
// 遍历一遍队列【想要找到一把、非空没回收、可用、仍在耐心等待共享资源的队列中的排队锁】：
            // 当前队列是，入队时间升序，超时时间【应该也是升序】，因为同样的锁的使用上下文场景（对应锁的默认超时时长一致），只有入队时间的先后不同与区别
            while (this.queue.Count > 0) { // 遍历队列：取有效锁住的第一请求资源者，释放资源？这里还得再想想，感觉还没能想透，不是释放资源，不是说释放一把锁，帮助请求方移往下一个逻辑执行分支的吗？去找，组件管理类里，什么情况下，需要调用 Notify() 方法  
                WaitCoroutineLock waitCoroutineLock = queue.Dequeue();
                if (waitCoroutineLock.IsDisposed()) continue; // 已经超时异常或回收（从 using() 处的用完回收）。队列中还有索引，但是空引用。从队列中将其清除
                CoroutineLock coroutineLock = CoroutineLock.Create(type, key, level); // 只有参数 level: 这个变量只标注相对层级。创建【共享资源当前独占锁】
// 释放了一把，队列里当前非空元素【异步资源异步等待锁】waitCoroutineLock，结果写回去了呀。
                // 写回去的结果说：亲爱的表哥的活宝妹，终于等到了亲爱的表哥来找活宝妹去领结婚证，亲爱的表哥同亲爱的表哥的活宝妹，终于可以【有情人终成眷属】！这纸结婚证，就是，接下来的余生，亲爱的表哥的活宝妹，同亲爱的表哥，【共享资源当前独占锁】互相只属于对方
                // 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
                waitCoroutineLock.SetResult(coroutineLock); 
                break;
            }
        }
        public void Recycle() {
            this.queue.Clear(); // 清空队列：是释放回收了队列里所有可能的元素。它是上级管理者创建的，这里会回收吗？会，就是上级字典的回收调用这里
            this.key = 0;
            this.type = 0;
            this.currentCoroutineLock = null; // 只有在当前任务被回收之后，它才可能为空
            ObjectPool.Instance.Recycle(this); // 释放回收这个类：到对象池，实现无GC. 它是一个队列，什么情况下会调用回收整个类、队列？
        }
    }
}
