#+latex_class: cn-article
#+title: ET 框架学习笔记（二）－－网络交互相关【爱表哥，爱生活！！！任何时候，活宝妹就是一定要嫁给亲爱的表哥！！！】
#+author: deepwaterooo 

* IAwake 接口类系统，IStart 重构丢了
- 感觉还比较直接，就是帮助搭建热更新域与Unity 常规工程域生命周期回调的桥，搭桥连线，连能就可以了。应该可以扩散出个IStart 接口类
** IMessage,IRequest,IResponse: 进程内的消息类。
- 这些接口的实现类是进程内的。一个使用的地方可以去看 NetServerComponentOnReadEvent.cs 类里的方法。
- 是一个进程内的消息，就直接调用（消息自带的会话框）会话框 OnResponse() 方法处理。
   #+BEGIN_SRC java
public interface IMessage {}
public interface IRequest: IMessage {
    int RpcId { get; set; }
}
public interface IResponse: IMessage {
    int Error { get; set; }
    string Message { get; set; }
    int RpcId { get; set; }
}
   #+END_SRC
** IActorMessage,IActorRequest,IActorResponse: 进程间的？消息类
- 这些，应该是就是【进程间消息】，必须使用消息处理器
   #+BEGIN_SRC java
// 不需要返回消息
public interface IActorMessage: IMessage {}
public interface IActorRequest: IRequest {}
public interface IActorResponse: IResponse {}
   #+END_SRC
** IActorLocationMessage: 进程间的位置消息相关
- 【进程间位置相关消息】：更具体一点儿。
   #+BEGIN_SRC java
public interface IActorLocationMessage: IActorRequest {}
public interface IActorLocationRequest: IActorRequest {}
public interface IActorLocationResponse: IActorResponse {}
   #+END_SRC
** IMHandler,IMActorHandler: 消息处理器口类【傻傻分不清楚】
   #+BEGIN_SRC java
public interface IMHandler { // 同进程内的
    void Handle(Session session, object message);
    Type GetMessageType();
    Type GetResponseType();
}
public interface IMActorHandler { // 进程间的？
    // ETTask Handle(Entity entity, int fromProcess, object actorMessage);
    void Handle(Entity entity, int fromProcess, object actorMessage); // 自已改成这样的
    Type GetRequestType();
    Type GetResponseType();
}
   #+END_SRC
** ILoad,ISystemType: 加载系
   #+BEGIN_SRC java
public interface ISystemType {
    Type Type();
    Type SystemType();
    InstanceQueueIndex GetInstanceQueueIndex();
}

public interface ILoad {
}
public interface ILoadSystem: ISystemType {
    void Run(Entity o);
}
[ObjectSystem]
public abstract class LoadSystem<T> : ILoadSystem where T: Entity, ILoad {
    void ILoadSystem.Run(Entity o) {
        this.Load((T)o);
    }
    Type ISystemType.Type() {
        return typeof(T);
    }
    Type ISystemType.SystemType() {
        return typeof(ILoadSystem);
    }
    InstanceQueueIndex ISystemType.GetInstanceQueueIndex() {
        return InstanceQueueIndex.Load;
    }
    protected abstract void Load(T self);
}
   #+END_SRC
** IAwake: 最多可以带四个参数
   #+BEGIN_SRC java
    public interface IAwake {}
    public interface IAwake<A> {}
    public interface IAwake<A, B> {}
    public interface IAwake<A, B, C> {}
    public interface IAwake<A, B, C, D> {}
   #+END_SRC
** IStartSystem,StartSystem<T>: 自己加的。【还有问题】系统找不到
   #+BEGIN_SRC java
public interface IStart { }
public interface IStartSystem : ISystemType {
    void Run(Entity o);
}
[ObjectSystem]
public abstract class StartSystem<T> : IStartSystem where T: Entity, IStart {
    public void IStartSystem.Run(Entity o) {
        this.Start((T)o);
    }
    public Type ISystemType.Type() {
        return typeof(T);
    }
    public Type ISystemType.SystemType() {
        return typeof(IStartSystem);
    }
    InstanceQueueIndex ISystemType.GetInstanceQueueIndex() { // 这里没看懂在干什么，大概还有个地方，我得去改
        return InstanceQueueIndex.Start; 
    }
    public abstract void Start(T self);
}
// 整合进了系统：InstanceQueueIndex
public enum InstanceQueueIndex {
    None = -1,
    Start, // 需要把这个回调加入框架统筹管理里去 
    Update,
    LateUpdate,
    Load,
    Max,
}
   #+END_SRC
- 参考项目：除了原文件放在ET 域。也【复制了一份到客户端的热更新域里】。可是感觉不应该。因为其它所有的回调都不用复制就可以用。我哪里可能还是没能设置对
- 改天再检查一下。但是否，对于非系统框架扩展接口，不得不这样？仍然感觉不应该，因为系统框架里其它的生命周期回调函数都不需要复制。
- *【编译报错：】* 热更新程序域里面，只能申明含有BaseAttribute 的子类特性的类或静态类。那么也就是说，我上面的，我哪怕是把同名文件复制到热更新程序域，也是不对的，因为框架不允许这么做。我就必须去找前面，模仿它的框架系统扩展的这个方法，哪里没能连通好，为什么它的系统方法只存在Model 域，就能运行好，而我添加的不可以？
** IUpdateSystem:
   #+BEGIN_SRC java
public interface IUpdate {
}
public interface IUpdateSystem: ISystemType {
    void Run(Entity o);
}
[ObjectSystem]
public abstract class UpdateSystem<T> : IUpdateSystem where T: Entity, IUpdate {
    void IUpdateSystem.Run(Entity o) {
        this.Update((T)o);
    }
    Type ISystemType.Type() {
        return typeof(T);
    }
    Type ISystemType.SystemType() {
        return typeof(IUpdateSystem);
    }
    InstanceQueueIndex ISystemType.GetInstanceQueueIndex() {
        return InstanceQueueIndex.Update;
    }
    protected abstract void Update(T self);
}
   #+END_SRC
** ILateUpdate: 好像是用于物理引擎，或是相机什么的更新，生命周期回调
   #+BEGIN_SRC java
public interface ILateUpdate {
}
public interface ILateUpdateSystem: ISystemType {
    void Run(Entity o);
}
[ObjectSystem]
public abstract class LateUpdateSystem<T> : ILateUpdateSystem where T: Entity, ILateUpdate {
    void ILateUpdateSystem.Run(Entity o) {
        this.LateUpdate((T)o);
    }
    Type ISystemType.Type() {
        return typeof(T);
    }
    Type ISystemType.SystemType() {
        return typeof(ILateUpdateSystem);
    }
    InstanceQueueIndex ISystemType.GetInstanceQueueIndex() {
        return InstanceQueueIndex.LateUpdate;
    }
    protected abstract void LateUpdate(T self);
}
   #+END_SRC
** ISingletonAwake|Update|LateUpdate: Singleton 生命周期回调
   #+BEGIN_SRC java
public interface ISingletonAwake {
    void Awake();
}
public interface ISingletonUpdate {
    void Update();
}
public interface ISingletonLateUpdate {
    void LateUpdate();
}
   #+END_SRC
** ISingleton,Singleton<T>: 单例
   #+BEGIN_SRC java
public interface ISingleton: IDisposable {
    void Register();
    void Destroy();
    bool IsDisposed();
}
public abstract class Singleton<T>: ISingleton where T: Singleton<T>, new() {
    private bool isDisposed;
    [StaticField]
    private static T instance;
    public static T Instance {
        get {
            return instance;
        }
    }
    void ISingleton.Register() {
        if (instance != null) {
            throw new Exception($"singleton register twice! {typeof (T).Name}");
        }
        instance = (T)this;
    }
    void ISingleton.Destroy() {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;

        instance.Dispose();
        instance = null;
    }
    bool ISingleton.IsDisposed() {
        return this.isDisposed;
    }
    public virtual void Dispose() {
    }
}
   #+END_SRC
** IDestroy,IDestroySystem,DestroySystem<T>: 销毁系
   #+BEGIN_SRC java
public interface IDestroy {
}
public interface IDestroySystem: ISystemType {
    void Run(Entity o);
}
[ObjectSystem]
public abstract class DestroySystem<T> : IDestroySystem where T: Entity, IDestroy {
    void IDestroySystem.Run(Entity o) {
        this.Destroy((T)o);
    }
    Type ISystemType.SystemType() {
        return typeof(IDestroySystem);
    }
    InstanceQueueIndex ISystemType.GetInstanceQueueIndex() {
        return InstanceQueueIndex.None;
    }
    Type ISystemType.Type() {
        return typeof(T);
    }
    protected abstract void Destroy(T self);
}
   #+END_SRC
** IEvent,AEvent<A>: 事件
   #+BEGIN_SRC java
public interface IEvent {
    Type Type { get; }
}
public abstract class AEvent<A>: IEvent where A: struct {
    public Type Type {
        get {
            return typeof (A);
        }
    }
    protected abstract ETTask Run(Scene scene, A a);
    public async ETTask Handle(Scene scene, A a) {
        try {
            await Run(scene, a);
        }
        catch (Exception e) {
            Log.Error(e);
        }
    }
}
   #+END_SRC
** IAddComponent: 添加组件系
   #+BEGIN_SRC java
    public interface IAddComponent { }
    public interface IAddComponentSystem: ISystemType {
        void Run(Entity o, Entity component);
    }
    [ObjectSystem]
    public abstract class AddComponentSystem<T> : IAddComponentSystem where T: Entity, IAddComponent {
        void IAddComponentSystem.Run(Entity o, Entity component) {
            this.AddComponent((T)o, component);
        }
        Type ISystemType.SystemType() {
            return typeof(IAddComponentSystem);
        }
        InstanceQueueIndex ISystemType.GetInstanceQueueIndex() {
            return InstanceQueueIndex.None;
        }
        Type ISystemType.Type() {
            return typeof(T);
        }
        protected abstract void AddComponent(T self, Entity component);
    }
   #+END_SRC
** IGetComponent: 获取组件系。【这里没有看明白】：再去找细节  // <<<<<<<<<<<<<<<<<<<< 
   #+BEGIN_SRC java
    // GetComponentSystem有巨大作用，比如每次保存Unit的数据不需要所有组件都保存，只需要保存Unit变化过的组件
    // 是否变化可以通过判断该组件是否GetComponent，Get了就记录该组件【这里没有看明白】：再去找细节  // <<<<<<<<<<<<<<<<<<<< 
    // 这样可以只保存Unit变化过的组件
    // 再比如传送也可以做此类优化
    public interface IGetComponent {
    }
    public interface IGetComponentSystem: ISystemType {
        void Run(Entity o, Entity component);
    }
    [ObjectSystem]
    public abstract class GetComponentSystem<T> : IGetComponentSystem where T: Entity, IGetComponent {
        void IGetComponentSystem.Run(Entity o, Entity component) {
            this.GetComponent((T)o, component);
        }
        Type ISystemType.SystemType() {
            return typeof(IGetComponentSystem);
        }
        InstanceQueueIndex ISystemType.GetInstanceQueueIndex() {
            return InstanceQueueIndex.None;
        }
        Type ISystemType.Type() {
            return typeof(T);
        }
        protected abstract void GetComponent(T self, Entity component);
    }
   #+END_SRC
** ISerializeToEntity,IDeserialize,IDeserializeSystem,DeserializeSystem<T>: 序列化，反序列化
   #+BEGIN_SRC java
public interface ISerializeToEntity {
}
public interface IDeserialize {
}
public interface IDeserializeSystem: ISystemType {
    void Run(Entity o);
}
// 反序列化后执行的System
[ObjectSystem]
public abstract class DeserializeSystem<T> : IDeserializeSystem where T: Entity, IDeserialize {
    void IDeserializeSystem.Run(Entity o) {
        this.Deserialize((T)o);
    }
    Type ISystemType.SystemType() {
        return typeof(IDeserializeSystem);
    }
    InstanceQueueIndex ISystemType.GetInstanceQueueIndex() {
        return InstanceQueueIndex.None;
    }
    Type ISystemType.Type() {
        return typeof(T);
    }
    protected abstract void Deserialize(T self);
}
   #+END_SRC
** IInvoke,AInvokeHandler<A>,AInvokeHandler<A, T>: 激活类
- 这个以前没有细看。现在修改编译错误的过程中，框架里有狠多细节的地方，需要修改的编译错误会一再崩出来，框架里出有狠多，有计时器来触发必要的超时等。所以今天，就把这类自带计时器，自动超时检测的激活系，这个功能模块理解一下。【半懂，大半懂，需要再多看几遍】
- 在以前理解了诸多标签，比如【ComponentOf(typeof())] 事件机制等，但是这个自动的激活系，一般与计时器联接紧密，要把这块儿理解透彻。
   #+BEGIN_SRC java
public interface IInvoke {
    Type Type { get; }
}
public abstract class AInvokeHandler<A>: IInvoke where A: struct {
    public Type Type {
        get {
            return typeof (A);
        }
    }
    public abstract void Handle(A a);
}
public abstract class AInvokeHandler<A, T>: IInvoke where A: struct {
    public Type Type {
        get {
            return typeof (A);
        }
    }
    public abstract T Handle(A a);
}
   #+END_SRC
** TimerInvokeType: 计时器可以自动触发的类型分类。
- 框架里有很多标签自动标记的标记系统。
- 这里类似。说，申明定义了这如下几类可以计时器自动触发的类型；当某个组件标记了可以计时器自动激活的标签，那么它申明的时间到，就会自动激活：某些某个特定的激活方法与逻辑，
- 如同7/1/2023, 如果活宝妹还没能嫁给亲爱的表哥，活宝妹就解决活宝妹在亲爱的表哥的身边的小镇上的住宿问题一样，有计时器到 6/30/2023. 有激活：7/1/2023 开始找和买长期住处。希望可以一个月内解决问题，7/31/2023 可以搬进去入住。再也不想跟任何的国际贱鸡掺合，把人烦死了。。。。。
#+BEGIN_SRC csharp
[UniqueId(100, 10000)]
public static class TimerInvokeType {
    // 框架层100-200，逻辑层的timer type从200起
    public const int WaitTimer = 100;
    public const int SessionIdleChecker = 101;
    public const int ActorLocationSenderChecker = 102;
    public const int ActorMessageSenderChecker = 103;
    // 框架层100-200，逻辑层的timer type 200-300
    public const int MoveTimer = 201;
    public const int AITimer = 202;
    public const int SessionAcceptTimeout = 203;
}
#+END_SRC
** struct TimerCallback: 
#+BEGIN_SRC csharp
// 计时器：所涉及的方方面面
public enum TimerClass { // 类型：
    None,      // 无
    OnceTimer, // 一次性
    OnceWaitTimer,  // 一次性要等待的计时器
    RepeatedTimer,  // 重复性、周期性计时器
}
public class TimerAction {
    public static TimerAction Create(long id, TimerClass timerClass, long startTime, long time, int type, object obj) {
        TimerAction timerAction = ObjectPool.Instance.Fetch<TimerAction>();
        timerAction.Id = id;
        timerAction.TimerClass = timerClass;
        timerAction.StartTime = startTime;
        timerAction.Object = obj;
        timerAction.Time = time;
        timerAction.Type = type;
        return timerAction;
    }
    public long Id;
    public TimerClass TimerClass;
    public object Object;
    public long StartTime;
    public long Time;
    public int Type;
    public void Recycle() {
        this.Id = 0;
        this.Object = null;
        this.StartTime = 0;
        this.Time = 0;
        this.TimerClass = TimerClass.None;
        this.Type = 0;
        ObjectPool.Instance.Recycle(this);
    }
}
public struct TimerCallback { // 在标签系中会用到计时器的回调
    public object Args;
}
#+END_SRC
** ATimer<T>: AInvokeHandler<TimerCallback>: 抽象类
#+BEGIN_SRC csharp
public abstract class ATimer<T>: AInvokeHandler<TimerCallback> where T: class {
    public override void Handle(TimerCallback a) {
        this.Run(a.Args as T);
    }
    protected abstract void Run(T t);
}
#+END_SRC
** InvokeAttribute: BaseAttribute, 【Invoke(type)】标签属性
- 这里仍然还没连通：先前只是定义了几个可以计时器定时到时激活的类型；这里只是属性标明激活类型
- 类型的幕后：怎么通过不同的类型，来区分不同长短的计时时间，并在特定的激活时间点，激活的？
- 不同超时类型的超时时长：举个例子：ActorMessageSenderComponent
  - ActorMessageSenderComponent: 这个组件里有个计时器自动计时的超时时段、特定超时类型的超时时长成员变量
  - 超时时间：这个组件有计时器自动计时和超时激活的逻辑，这里定义了这个组件类型的超时时长，在ActorMessageSenderComponentSystem.cs 文件的 *【Invoke(TimerInvokeType.ActorMessageSenderChecker)】* 标注的ActorMessageSenderChecker 里会用到，检测超时与否
#+BEGIN_SRC csharp
public class InvokeAttribute: BaseAttribute {
    public int Type { get; }
    public InvokeAttribute(int type = 0) {
        this.Type = type;
    }
}
#+END_SRC
** ActorMessageSenderComponentSystem::ActorMessageSenderChecker 类中类，计时器自动计时标签激活系【诲涩难懂，多看几遍】
- 上面只是计时器的类型。不同类型内部自带计时器超时的特定类型所规定的超时时间。类型的内部自定义超时处理逻辑。用激活标签标明计时器超时的类型，以便与超时时长，和超时后的处理逻辑一一对应。【爱表哥，爱生活！！！任何时候，活宝妹就是一定要嫁给亲爱的表哥！！！爱表哥，爱生活！！！】
- 再找一个激活标签的实体类，作参考，把流程理解透彻。
- 【例子：计时器计时超时消息过滤器过滤超时消息原理】：过滤器里，一旦有某个消息超时，就会自动触发检测：是否有一批消息超时，检测到第一个不超时的，就退出循环检测；把所有超时的消息，一一返回超时错误码给消息发送者，提醒它们出错，必要时它们可以重发。。。
- 【还没连通的地方是：】写好错误码的返回消息，结果写到了ETTask 异步任务的异常里，错误码抛出异常，ETTask 会同步异常、写入异常、并抛出异常。
  - 又想到一点，ActorMessageSender, 既可以是发送消息者发送消息的发送器，也可以是，错误码返回消息的发送器。那么就是说，ActorMessageSenderComponent 的循环逻辑某处，是可以发返回消息的。【上面想的不对。 *在框架的相对上层，当内网NetInnerComponent 读到消息，发布读到消息事件，会自动触发读到消息事件的订阅者——NetInnerComponentOnReadEvent 来，借助消息处理器帮助类 ActorHandleHelper 类，对不同类型的消息进行分发处理。而帮助类的内部，就是调用这里的底层方法定义。帮助类应该可以更好地区分消息处理的逻辑流程先后顺序。* 】
  - 发送消息超时异常，不走发返回消息路径，而是直接由ETTask 抛异常，不需要发返回消息。Run() 方法被其它情境下调用（被读到消息事件的订阅者，借助消息处理器帮助类，来调用这里的底层方法，处理正常的返回消息），才会发返回消息，系统的后半部分，有发送消息的逻辑。今天上午把这块读懂，下午回去改这块儿的重构与编译错误。
- 亲爱的表哥，感觉你活宝妹努力认真去读懂一个艰深诲涩难懂的模块或是功能逻辑的时候，活宝妹的小鼠标，还是会偶尔落到不小心落到永远不想去落的位置。敬请他们大可不必发疯犯贱，把人都烦死了。活宝妹永远只问：活宝妹嫁给亲爱的表哥了吗？活宝妹被他们的国际贱鸡折磨致死了吗？都还没有，他们就大可不必发疯犯贱。任何时候，亲爱的表哥的活宝妹，就是都是一定要嫁给亲爱的表哥的！！！爱表哥，爱生活！！！
#+BEGIN_SRC csharp
[FriendOf(typeof(ActorMessageSenderComponent))]
public static class ActorMessageSenderComponentSystem {
    // 它自带个计时器，就是说，当服务器繁忙处理不过来，它就极有可能会自动超时，若是超时了，就返回个超时消息回去发送者告知一下，必要时它可以重发。而不超时，就正常基本流程处理了.那么，它就是一个服务端超负载下的自动减压逻辑
    [Invoke(TimerInvokeType.ActorMessageSenderChecker)] // 另一个新标签，激活系: 它标记说，这个激活系类，是 XXX 类型；紧跟着，就定义这个 XXX 类型的激活系类
    public class ActorMessageSenderChecker: ATimer<ActorMessageSenderComponent> {
        protected override void Run(ActorMessageSenderComponent self) { // 申明方法的接口是：ATimer<T> 抽象实现类，它实现了 AInvokeHandler<TimerCallback>
            try {
                self.Check(); // 调用组件自己的方法
             } catch (Exception e) {
                Log.Error($"move timer error: {self.Id}\n{e}");
            }
        }
    }//...
// Run() 方法：通过同步异常到ETTask, 通过ETTask 封装的抛异常方式抛出两类异常并返回；和对正常非异常返回消息，同步结果到ETTask, ETTask() 用触发调用注册过的非空回调
// 传进来的参数：是一个IActorResponse 实例，是有最小预处理（初始化了最基本成员变量：异常类型）、【写了个半好】的结果（异常）。结果还没同步到异步任务，待写；返回消息，待发送
    private static void Run(ActorMessageSender self, IActorResponse response) { 
        // 对于每个超时了的消息：超时错误码都是：ErrorCore.ERR_ActorTimeout, 所以会从发送消息超时异常里抛出异常，不用发送错误码【消息】回去，是抛异常
        if (response.Error == ErrorCore.ERR_ActorTimeout) { // 写：发送消息超时异常。因为同步到异步任务 ETTask 里，所以异步任务模块 ETTask会自动抛出异常
            self.Tcs.SetException(new Exception($"Rpc error: request, 注意Actor消息超时，请注意查看是否死锁或者没有reply: actorId: {self.ActorId} {self.Request}, response: {response}"));
            return;
        }
// 这个Run() 方法，并不是只有 Check() 【发送消息超时异常】一个方法调用。什么情况下的调用，会走到下面的分支？文件尾，有正常消息同步结果到ETTask 的调用 
// ActorMessageSenderComponent 一个组件，一次只执行一个（返回）消息发送任务，成员变量永远只管当前任务，
// 也是因为Actor 机制是并行的，一个使者一次只能发一个消息 ...
// 【组件管理器的执行频率， Run() 方法的调用频率】：要是消息太多，发不完怎么办呢？去搜索下面调用 Run() 方法的正常结果消息的调用处理频率。。。
        if (self.NeedException && ErrorCore.IsRpcNeedThrowException(response.Error)) { // 若是有异常（判断条件：消息要抛异常否？是否真有异常？），就先抛异常
            self.Tcs.SetException(new Exception($"Rpc error: actorId: {self.ActorId} request: {self.Request}, response: {response}"));
            return;
        }
        self.Tcs.SetResult(response); // 【写结果】：将【写了个半好】的消息，写进同步到异步任务的结果里；把异步任务的状态设置为完成；并触发必要的非空回调到发送者
        // 上面【异步任务 ETTask.SetResult()】，会调用注册过的一个回调，所以ETTask 封装，设置结果这一步，会自动触发调用注册过的一个回调（如果没有设置回调，因为空，就不会调用）
        // ETTask.SetResult() 异步任务写结果了，非空回调是会调用。非空回调是什么，是把返回消息发回去吗？不是。因为有独立的发送逻辑。
        // 再去想 IMHandler: 它是消息处理器。问题就变成是，当返回消息写好了，写好了一个完整的可以发送、待发送的消息，谁来处理的？有某个更底层的封装会调用这个类的发送逻辑。去把这个更底层的封装找出来，就是框架封装里，调用这个生成类Send() 方法的地方。
        // 这个服，这个自带计时器减压装配装置自带的消息处理器逻辑会处理？不是这个。减压装置，有发送消息超时，只触发最小检测，并抛发送消息超时异常给发送者告知，不写任何结果消息 
    }
    private static void Check(this ActorMessageSenderComponent self) {
        long timeNow = TimeHelper.ServerNow();
        foreach ((int key, ActorMessageSender value) in self.requestCallback) {
            // 因为是顺序发送的，所以，检测到第一个不超时的就退出
            // 超时触发的激活逻辑：是有至少一个超时的消息，才会【激活触发检测】；而检测到第一个不超时的，就退出下面的循环。
            if (timeNow < value.CreateTime + ActorMessageSenderComponent.TIMEOUT_TIME) 
                break;
            self.TimeoutActorMessageSenders.Add(key);
        }
// 超时触发的激活逻辑：是有至少一个超时的消息，才会【激活触发检测】；而检测到第一个不超时的，就退出上面的循环。
// 检测到第一个不超时的，理论上说，一旦有一个超时消息就会触发超时检测，但实际使用上，可能存在当检测逻辑被触发走到这里，实际中存在两个或是再多一点儿的超时消息？
        foreach (int rpcId in self.TimeoutActorMessageSenders) { // 一一遍历【超时了的消息】 :
            ActorMessageSender actorMessageSender = self.requestCallback[rpcId];
            self.requestCallback.Remove(rpcId);
            try { // ActorHelper.CreateResponse() 框架系统性的封装：也是通过对消息的发送类型与对应的回复类型的管理，使用帮助类，自动根据类型统一创建回复消息的实例
                // 对于每个超时了的消息：超时错误码都是：ErrorCore.ERR_ActorTimeout. 也就是，是个异常消息的回复消息实例生成帮助类
                IActorResponse response = ActorHelper.CreateResponse(actorMessageSender.Request, ErrorCore.ERR_ActorTimeout);
                Run(actorMessageSender, response); // 猜测：方法逻辑是，把回复消息发送给对应的接收消息的 rpcId
            } catch (Exception e) {
                Log.Error(e.ToString());
            }
        }
        self.TimeoutActorMessageSenders.Clear();
    }

    public static void Send(this ActorMessageSenderComponent self, long actorId, IMessage message) { // 发消息：这个方法，发所有类型的消息，最基接口
        if (actorId == 0) 
            throw new Exception($"actor id is 0: {message}");
        ProcessActorId processActorId = new(actorId);
        // 这里做了优化，如果发向同一个进程，则直接处理，不需要通过网络层
        if (processActorId.Process == Options.Instance.Process) { // 没看懂：这里怎么就说，消息是发向同一进程的了？
            NetInnerComponent.Instance.HandleMessage(actorId, message); // 原理清楚：本进程消息，直接交由本进程内网组件处理
            return;
        }
        Session session = NetInnerComponent.Instance.Get(processActorId.Process); // 非本进程消息，去走网络层
        session.Send(processActorId.ActorId, message);
    }
    public static int GetRpcId(this ActorMessageSenderComponent self) {
        return ++self.RpcId;
    }
// 这个方法：只对当前进程的发送要求IActorResponse 的消息，封装自家进程的 rpcId, 也就是标明本进程发的消息，来自其它进程的返回消息，到时发到本进程。是特殊使用
    public static async ETTask<IActorResponse> Call(
        this ActorMessageSenderComponent self,
        long actorId,
        IActorRequest request,
        bool needException = true
        ) {
        request.RpcId = self.GetRpcId(); // 封装本进程的 rpcId 
        if (actorId == 0) throw new Exception($"actor id is 0: {request}");
        return await self.Call(actorId, request.RpcId, request, needException);
    }
// 【艰森诲涩难懂！！】是更底层的实现细节，它封装帮助实现ET7 里消息超时自动过滤抛异常、返回消息的底层封装自动回复、封装了异步任务和必要成员变量来实现这些辅助过滤器等功能 
    public static async ETTask<IActorResponse> Call( // 跨进程发请求消息（要求回复）：返回跨进程异步调用结果。是 await 关键字调用，用在异步方法里
        this ActorMessageSenderComponent self,
        long actorId,
        int rpcId,
        IActorRequest iActorRequest,
        bool needException = true
        ) {
        if (actorId == 0) 
            throw new Exception($"actor id is 0: {iActorRequest}");
// 对象池里：取一个异步任务。用这个异步作务实例，去创建下面的消息发送器实例。这里的 IActorResponse T 应该只是一个索引。因为前面看见系统扫描标签系创建返回实例，套到这个索引
        var tcs = ETTask<IActorResponse>.Create(true);
        // 下面，封装好消息发送器，交由消息发送组件管理；交由其管理，就自带消息发送计时超时过滤机制，实现服务器超负荷时的自动分压减压处理。一旦超时自动报废。。。
        self.requestCallback.Add(rpcId, new ActorMessageSender(actorId, iActorRequest, tcs, needException)); 
        self.Send(actorId, iActorRequest); // 把请求消息发出去：所有消息，都调用这个 
        long beginTime = TimeHelper.ServerFrameTime();
// 自己想一下的话：异步消息发出去，某个服会处理，有返回消息的话，这个服处理后会返回一个返回消息。
// 那么下面一行，不是等待创建 Create() 异步任务（同步方法狠快），而是等待这个处理发送消息的服，处理并返回来返回消息（是说，那个服，把处理结果同步到异步任务）
// 不是等异步任务的创建完成（同步方法狠快），实际是等处理发送消息的服，处理完并写好返回消息，同步到异步任务。
// 那个ETTask 里的回调 callback，是怎么回调的？这里Tcs 没有设置任何回调。ETTask 里所谓回调，是执行异步状态机的下一步，没有实际应用层面的回调意义
// 或说把返回消息的内容填好，【应该还没发回到消息发送者？？？】返回消息填好了，ETTask 异步任务的结果同步到位了，底层会自动发回来
// 【异步任务结果是怎么回来的？】是前面看过的IMHandler 的底层封装（AMRpcHandler 的抽象逻辑里）发送回来的。ET7 IMHandler 不是重构实现了返回消息的自动发送回复给发送者吗？再去看一遍。
        IActorResponse response = await tcs;  // 等待消息处理服处理完，写好同步好结果到异步任务、异步任务执行完成，状态为 Succeed
        long endTime = TimeHelper.ServerFrameTime();
        long costTime = endTime - beginTime;
        if (costTime > 200) 
            Log.Warning($"actor rpc time > 200: {costTime} {iActorRequest}");
        return response; // 返回：异步网络调用的结果
    }
// 【组件管理器的执行频率， Run() 方法的调用频率】：要是消息太多，发不完怎么办呢？去搜索下面调用 Run() 方法的正常结果消息的调用处理频率。。。
// 【ActorHandleHelper 帮助类】：老是调用这里的方法，要去查那个文件。【本质：内网消息处理器的处理逻辑，一旦是返回消息，就会调用 ActorHandleHelper, 会调用这个方法来处理返回消息】        
// 下面方法：处理IActorResponse 消息，也就是，发回复消息给收消息的人XX, 那么谁发，怎么发，就是这个方法的定义
    // 当是处理【同一进程的消息】：拿到的消息发送器就是当前组件自己，那么只要把结果同步到当前组件的Tcs 异步任务结果里，异步任务结果就会自动触发调用注册过的回调。全部流程结束
    public static void HandleIActorResponse(this ActorMessageSenderComponent self, IActorResponse response) {
        ActorMessageSender actorMessageSender;
// 下面取、实例化 ActorMessageSender 来看，感觉收消息的 rpcId, 与消息发送者 ActorMessageSender 成一一对应关系。上面的Call() 方法里，创建实例化消息发送者就是这么创始垢 
        if (!self.requestCallback.TryGetValue(response.RpcId, out actorMessageSender)) // 这里取不到，是说，这个返回消息的发送已经被处理了？
            return;
        self.requestCallback.Remove(response.RpcId); // 这个有序字典，就成为实时更新：随时添加，随时删除
        Run(actorMessageSender, response); // <<<<<<<<<<<<<<<<<<<< 
    }
}
#+END_SRC 
** ProtoBuf 相关：IExtensible,IExtension,IProtoOutput<TOutput>,IMeasuredProtoOutput<TOutput>,MeasureState<T>: 看不懂
*** IExtensible
   #+BEGIN_SRC java
// Indicates that the implementing type has support for protocol-buffer
// <see cref="IExtension">extensions</see>.
// <remarks>Can be implemented by deriving from Extensible.</remarks>
public interface IExtensible {
    // Retrieves the <see cref="IExtension">extension</see> object for the current
    // instance, optionally creating it if it does not already exist.
    // <param name="createIfMissing">Should a new extension object be
    // created if it does not already exist?</param>
    // <returns>The extension object if it exists (or was created), or null
    // if the extension object does not exist or is not available.</returns>
    // <remarks>The <c>createIfMissing</c> argument is false during serialization,
    // and true during deserialization upon encountering unexpected fields.</remarks>
    IExtension GetExtensionObject(bool createIfMissing);
}
   #+END_SRC
*** IExtension
    #+BEGIN_SRC java
// Provides addition capability for supporting unexpected fields during
// protocol-buffer serialization/deserialization. This allows for loss-less
// round-trip/merge, even when the data is not fully understood.
public interface IExtension {
    // Requests a stream into which any unexpected fields can be persisted.
    // <returns>A new stream suitable for storing data.</returns>
    Stream BeginAppend();
    // Indicates that all unexpected fields have now been stored. The
    // implementing class is responsible for closing the stream. If
    // "commit" is not true the data may be discarded.
    // <param name="stream">The stream originally obtained by BeginAppend.</param>
    // <param name="commit">True if the append operation completed successfully.</param>
    void EndAppend(Stream stream, bool commit);
    // Requests a stream of the unexpected fields previously stored.
    // <returns>A prepared stream of the unexpected fields.</returns>
    Stream BeginQuery();
    // Indicates that all unexpected fields have now been read. The
    // implementing class is responsible for closing the stream.
    // <param name="stream">The stream originally obtained by BeginQuery.</param>
    void EndQuery(Stream stream);
    // Requests the length of the raw binary stream; this is used
    // when serializing sub-entities to indicate the expected size.
    // <returns>The length of the binary stream representing unexpected data.</returns>
    int GetLength();
}
// Provides the ability to remove all existing extension data
public interface IExtensionResettable : IExtension {
    void Reset();
}
    #+END_SRC
*** IProtoOutput<TOutput>,IMeasuredProtoOutput<TOutput>,MeasureState<T>: 看得头大
    #+BEGIN_SRC java
// Represents the ability to serialize values to an output of type <typeparamref name="TOutput"/>
public interface IProtoOutput<TOutput> {
    // Serialize the provided value
    void Serialize<T>(TOutput destination, T value, object userState = null);
}
// Represents the ability to serialize values to an output of type <typeparamref name="TOutput"/>
// with pre-computation of the length
public interface IMeasuredProtoOutput<TOutput> : IProtoOutput<TOutput> {
    // Measure the length of a value in advance of serialization
    MeasureState<T> Measure<T>(T value, object userState = null);
    // Serialize the previously measured value
    void Serialize<T>(MeasureState<T> measured, TOutput destination);
}
// Represents the outcome of computing the length of an object; since this may have required computing lengths
// for multiple objects, some metadata is retained so that a subsequent serialize operation using
// this instance can re-use the previously calculated lengths. If the object state changes between the
// measure and serialize operations, the behavior is undefined.
public struct MeasureState<T> : IDisposable {
// note: * does not actually implement this API;
// it only advertises it for 3.* capability/feature-testing, i.e.
// callers can check whether a model implements
// IMeasuredProtoOutput<Foo>, and *work from that*
    public void Dispose() => throw new NotImplementedException();
    public long Length => throw new NotImplementedException();
}
    #+END_SRC


* Protobuf 里的 enum: 【Identity】【Suits】【Weight】
** OuterMessage_C_10001.proto 里三四个类的定义
- 感觉更多的是命名空间没能弄对。同一份源码一式三份，分别放在【客户端】【双端】【服务端】下只有【客户端】下可以通过读 Card 类的定义，可以知道能自动识别，并且 Protobuf 里的 enum 生成的 .cs 与参考项目不同。不知道是否是 Protobuf 版本问题，还是我没注意到的细节。
   #+BEGIN_SRC java
enum Identity { // 身份
    IdentityNone = 0;
    Farmer = 1;     // 平民
    Landlord = 2;   // 地主
}
enum Suits { // 花色
    Club = 0;    // 梅花
    Diamond = 1; // 方块
    Heart = 2;   // 红心
    Spade = 3;   // 黑桃
    None = 4;
}
enum Weight { // 权重
    Three = 0;      // 3
    Four = 1;       // 4
    Five = 2;       // 5
    Six = 3;        // 6
    Seven = 4;      // 7
    Eight = 5;      // 8
    Nine = 6;       // 9
    Ten = 7;        // 10
    Jack = 8;       // J
    Queen = 9;      // Q
    King = 10;       // K
    One = 11;        // A
    Two = 12;        // 2
    SJoker = 13;     // 小王
    LJoker = 14;     // 大王
}
message Card {
    Weight CardWeight = 1;
    Suits CardSuits = 2;
}
   #+END_SRC
** 【参考项目】里： enum 是可以顺利写进 ETModel 申明的命名空间，并且源码可见
   #+BEGIN_SRC java
namespace ETModel {
#region Enums
    public enum Suits {
        Club = 0,
        Diamond = 1,
        Heart = 2,
        Spade = 3,
        None = 4,
    }
    public enum Weight {
        Three = 0,
        Four = 1,
        Five = 2,
        Six = 3,
        Seven = 4,
        Eight = 5,
        Nine = 6,
        Ten = 7,
        Jack = 8,
        Queen = 9,
        King = 10,
        One = 11,
        Two = 12,
        Sjoker = 13,
        Ljoker = 14,
    }
    public enum Identity {
        None = 0,
        Farmer = 1,
        Landlord = 2,
    }
#endregion
#region Messages
   #+END_SRC
** ET7 框架里， enum 完全找不到
- 一种网络上没能理解透彻的可能是：我不能把三个 enum 类单独列出来，而是把三个类嵌套在必要的需要使用这些 enum 的 message 的定义里，举例如下：
- 如下，对于Card 类应该是行得通的。可是问题是，我的 card 本来也没有问题。有问题的是，三个 enum 类找不到。那么也就是，我大概还是需要手动定义这三个类在程序的某些域某些地方。【确认一下】 
#+BEGIN_SRC java
message SearchRequest {
    string query = 1;
    int32 page_number = 2;
    enum Corpus { // enum 成员变量一定义嵌套
        UNIVERSAL = 0;
        WEB = 1;
        IMAGES = 2;
        LOCAL = 3;
        NEWS = 4;
        PRODUCTS = 5;
        VIDEO = 6;
    }
    Corpus corpus = 4; // enum 成员变量一定义赋值
}
#+END_SRC
- 觉得这个，是目前最主要的 compile-error 的来源，但不是自己重构项目的重点，还是去看其它的。看如何重构现项目。这个晚上再弄。
** ETModel_Card_Binding: 奇异点，ILRuntime 热更新里，似乎对 Card 类的两个成员变量作了辅助链接
- 还没有细看，不是狠懂这里的原理。但在解决上面的问题之后，如果这两个变量仍不通，会参考这里
   #+BEGIN_SRC java
unsafe class ETModel_Card_Binding {
    public static void Register(ILRuntime.Runtime.Enviorment.AppDomain app) {
        BindingFlags flag = BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly;
        MethodBase method;
        Type[] args;
        Type type = typeof(ETModel.Card);
        args = new Type[]{};
        method = type.GetMethod("GetName", flag, null, args, null);
        app.RegisterCLRMethodRedirection(method, GetName_0);
        args = new Type[]{};
        method = type.GetMethod("get_CardWeight", flag, null, args, null);
        app.RegisterCLRMethodRedirection(method, get_CardWeight_1);
        args = new Type[]{};
        method = type.GetMethod("get_CardSuits", flag, null, args, null);
        app.RegisterCLRMethodRedirection(method, get_CardSuits_2);
        args = new Type[]{};
        method = type.GetMethod("get_Parser", flag, null, args, null);
        app.RegisterCLRMethodRedirection(method, get_Parser_3);
    }
   #+END_SRC


* 【拖拉机游戏房间】组件: 分析
** TractorRoomEvent: 拖拉机房间，【待修改完成】 
#+BEGIN_SRC java
// UI 系统的事件机制：定义，如何创建拖拉机游戏房间【TODO:】UNITY 里是需要制作相应预设的
[UIEvent(UIType.TractorRoom)]
public class TractorRoomEvent: AUIEvent {
    public override async ETTask<UI> OnCreate(UIComponent uiComponent, UILayer uiLayer) {
        await ETTask.CompletedTask;
        await uiComponent.DomainScene().GetComponent<ResourcesLoaderComponent>().LoadAsync(UIType.TractorRoom.StringToAB());

        GameObject bundleGameObject = (GameObject) ResourcesComponent.Instance.GetAsset(UIType.TractorRoom.StringToAB(), UIType.TractorRoom);
        GameObject room = UnityEngine.Object.Instantiate(bundleGameObject, UIEventComponent.Instance.GetLayer((int)uiLayer));
        UI ui = uiComponent.AddChild<UI, string, GameObject>(UIType.TractorRoom, room);
        // 【拖拉机游戏房间】：它可能由好几个不同的组件组成，这里要添加的不止一个
        ui.AddComponent<GamerComponent>(); // 玩家组件：这个控件带个UI 小面板，要怎么添加呢？
        ui.AddComponent<TractorRoomComponent>(); // <<<<<<<<<<<<<<<<<<<< 房间组件：合成组件系统，自带【互动组件】
        return ui;
    }
    public override void OnRemove(UIComponent uiComponent) {
        ResourcesComponent.Instance.UnloadBundle(UIType.TractorRoom.StringToAB());
    }
}
#+END_SRC
** GamerComponent: 玩家【管理类组件】，是对房间里四个玩家的管理。
- 【GamerComponent】玩家组件：是对一个房间里四个玩家的（及其在房间里的坐位位置）管理（分东南西北）。可以添加移除玩家。
   #+BEGIN_SRC java
// 组件：是提供给房间用，用来管理游戏中每个房间里的最多三个当前玩家
public class GamerComponent : Entity, IAwake { // 它也有【生成系】
    private readonly Dictionary<long, int> seats = new Dictionary<long, int>();
    private readonly Gamer[] gamers = new Gamer[4]; 
    public Gamer LocalGamer { get; set; } // 提供给房间组件用的：就是当前玩家。。。
    // 添加玩家
    public void Add(Gamer gamer, int seatIndex) {
        gamers[seatIndex] = gamer;
        seats[gamer.UserID] = seatIndex;
    }
    // 获取玩家
    public Gamer Get(long id) {
        int seatIndex = GetGamerSeat(id);
        if (seatIndex >= 0) 
            return gamers[seatIndex];
        return null;
    }
    // 获取所有玩家
    public Gamer[] GetAll() {
        return gamers;
    }
    // 获取玩家座位索引
    public int GetGamerSeat(long id) {
        int seatIndex;
        if (seats.TryGetValue(id, out seatIndex)) 
            return seatIndex;
        return -1;
    }
    // 移除玩家并返回
    public Gamer Remove(long id) {
        int seatIndex = GetGamerSeat(id);
        if (seatIndex >= 0) {
            Gamer gamer = gamers[seatIndex];
            gamers[seatIndex] = null;
            seats.Remove(id);
            return gamer;
        }
        return null;
    }
    public override void Dispose() {
        if (this.IsDisposed) 
            return;
        base.Dispose();
        this.LocalGamer = null;
        this.seats.Clear();
        for (int i = 0; i < this.gamers.Length; i++) 
            if (gamers[i] != null) {
                gamers[i].Dispose();
                gamers[i] = null;
            }
    }
}
   #+END_SRC
** Gamer: 【服务端】一个玩家个例。对应这个玩家的相关信息
   #+BEGIN_SRC java
// 房间玩家对象
public sealed class Gamer : Entity, IAwake<long> {
    // 用户ID（唯一）
    public long UserID { get; private set; }
    // 玩家GateActorID
    public long PlayerID { get; set; }
    // 玩家所在房间ID
    public long RoomID { get; set; }
    // 是否准备
    public bool IsReady { get; set; }
    // 是否离线
    public bool isOffline { get; set; }
    public void Awake(long id) {
        this.UserID = id;
    }
    public override void Dispose() {
        if (this.IsDisposed) return;
        base.Dispose();
        this.UserID = 0;
        this.PlayerID = 0;
        this.RoomID = 0;
        this.IsReady = false;
        this.isOffline = false;
    }
}
   #+END_SRC
** Gamer: 【客户端】一个玩家个例。它说只要一点儿信息就行
- 传进程间消息的时候，也只传这两个关键参数。
   #+BEGIN_SRC java
public sealed class Gamer : Entity { // 玩家对象
    // 玩家唯一ID
    public long UserID { get; set; }
    // 是否准备
    public bool IsReady { get; set; }
    public override void Dispose() {
        if (this.IsDisposed) return;
        base.Dispose();
        this.UserID = 0;
        this.IsReady = false;
    }
}
   #+END_SRC
** GamerUIComponent: 【客户端】玩家UI 组件：每个玩家背个小面板，来显示必要信息（钱，抢不抢庄，反过的主等）
   #+BEGIN_SRC java
public class GamerUIComponent : Entity, IStart { // 玩家UI组件
    public GameObject Panel { get; private set; } // UI面板
    // 玩家昵称
    public string NickName { get { return name.text; } }
    private Image headPhoto;
    private Text prompt;
    private Text name;
    private Text money;
    public void Start() {
        if (this.GetParent<Gamer>().IsReady) 
            SetReady();
    }
    // 重置面板
    public void ResetPanel() {
        ResetPrompt();
        this.headPhoto.gameObject.SetActive(false);
        this.name.text = "空位";
        this.money.text = "";
        this.Panel = null;
        this.prompt = null;
        this.name = null;
        this.money = null;
        this.headPhoto = null;
    }
    // 设置面板
    public void SetPanel(GameObject panel) {
        this.Panel = panel;
        // 绑定关联
        this.prompt = this.Panel.Get<GameObject>("Prompt").GetComponent<Text>();
        this.name = this.Panel.Get<GameObject>("Name").GetComponent<Text>();
        this.money = this.Panel.Get<GameObject>("Money").GetComponent<Text>();
   p     this.headPhoto = this.Panel.Get<GameObject>("HeadPhoto").GetComponent<Image>();
        UpdatePanel();
    }
    // 更新面板
    public void UpdatePanel() {
        if (this.Panel != null) {
            SetUserInfo();
            headPhoto.gameObject.SetActive(false);
        }
    }
    // 设置玩家身份
    public void SetIdentity(Identity identity) {
        if (identity == Identity.None) return;
        string spriteName = $"Identity_{Enum.GetName(typeof(Identity), identity)}";
        Sprite headSprite = CardHelper.GetCardSprite(spriteName);
        headPhoto.sprite = headSprite;
        headPhoto.gameObject.SetActive(true);
    }
    // 玩家准备
    public void SetReady() {
        prompt.text = "准备！";
    }
    // 出牌错误
    public void SetPlayCardsError() {
        prompt.text = "您出的牌不符合规则！";
    }
    // 玩家不出
    public void SetDiscard() {
        prompt.text = "不出";
    }
    // 打2 时，玩家抢不抢庄：或者去想，玩家要不要反主牌花色
    public void SetGrab(GrabLandlordState state) {
        switch (state) {
        case GrabLandlordState.Not:
            break;
        case GrabLandlordState.Grab:
            prompt.text = "抢地主";
            break;
        case GrabLandlordState.UnGrab:
            prompt.text = "不抢";
            break;
        }
    }
    public void ResetPrompt() { // 重置提示
        prompt.text = "";
    }
    public void GameStart() { // 游戏开始
        ResetPrompt();
    }
    private async void SetUserInfo() { // 设置用户信息
        G2C_GetUserInfo_Ack g2C_GetUserInfo_Ack = await SessionComponent.Instance.Session.Call(new C2G_GetUserInfo_Req() { UserID = this.GetParent<Gamer>().UserID }) as G2C_GetUserInfo_Ack;
        if (this.Panel != null) {
            name.text = g2C_GetUserInfo_Ack.NickName;
            money.text = g2C_GetUserInfo_Ack.Money.ToString();
        }
    }
    public override void Dispose() {
        if (this.IsDisposed) return;
        base.Dispose();
        ResetPanel(); // 重置玩家UI
    }
}
   #+END_SRC
** Protobuf 里面的消息与参考 
- 这里把 Protobuf 里面可以传的游戏相关也整理一下。
   #+BEGIN_SRC java
message GamerInfo {
    int64 UserID = 1;
    bool IsReady = 2;
}
message GamerScore {
    int64 UserID = 1;
    int64 Score = 2;
}
message GamerState {
    int64 UserID = 1;
    ET.Server.Identity UserIdentity = 2; // 命名空间的问题
	GrabLandlordState State = 3;
}
message GamerCardNum { // IMessage
    int64 UserID = 1;
    int32 Num = 2;
}
message Actor_GamerGrabLandlordSelect_Ntt { // IActorMessage 参考去想：抢庄，与反主牌花色，如何写消息 
    int32 RpcId = 90;
    int64 ActorId = 94;
    int64 UserID = 1;
    bool IsGrab = 2;
}
   #+END_SRC
** TractorRoomComponent: 游戏房间，自带其它组件，当有嵌套时，如何才能系统化地、工厂化地、UI 上的事件驱动地，生成这个组件呢？
   #+BEGIN_SRC java
public class TractorRoomComponent : Entity, IAwake {
    private TractorInteractionComponent interaction; // 嵌套组件：互动组件
    private Text multiples;
    public readonly GameObject[] GamersPanel = new GameObject[4];
    public bool Matching { get; set; }
    public TractorInteractionComponent Interaction { // 组件里套组件，要如何事件机制触发生成？
        get {
            if (interaction == null) {
                UI uiRoom = this.GetParent<UI>();
                UI uiInteraction = TractorInteractionFactory.Create(UIType.TractorInteraction, uiRoom);
                interaction = uiInteraction.GetComponent<TractorInteractionComponent>();
            }
            return interaction;
        }
    }
   #+END_SRC
** TractorInteractionComponent: 感觉是视图UI 上的一堆调控，逻辑控制
- 上下这一两个组件里，除了 ProtoBuf 消息里传递的类找不到，没有其它错误
- 【嵌套】：是这里的难点。其它都可以一个触发一个地由事件发布触发订阅者的回调，可是当一个组件内存在嵌套，又是系统化【内部组件生成完成后，外部组件才生成完成】生成，我是要把这两个组件合并成一个吗？还是说，我不得不把它折成粒度更小的UI 上的事件驱动机制，以符合系统框架？要去所源码弄透。
   #+BEGIN_SRC java
// 【互动组件】：一堆的视图控件管理 
public class TractorInteractionComponent : Entity, IAwake { // 多个按钮：有些暂时是隐藏的
    private Button playButton;
    private Button promptButton;
    private Button discardButton;
    private Button grabButton;
    private Button disgrabButton;
    private Button changeGameModeButton;
    private List<Card> currentSelectCards = new List<Card>();

    public bool isTrusteeship { get; set; }
    public bool IsFirst { get; set; }
   #+END_SRC

* ET7 数据库相关【服务端】
- 这个数据库系统，连个添加使用的范例也没有。。。就两个组件，一个管理类。什么也没留下。。
- 现框架 *DB 放在服务端的Model* 里。它的管理体系成为管理各个不同区服的数据库 DBComponent。
- 因为找不到任何参考使用的例子。我觉得需要搜索一下。在理解了参考项目数据库模块之后，根据搜索，决定是使用原参考项目总服务器代理系，还是这种相对改装了的管理区服系统？
- 先前搜的时候，关于应用框架的数据缓存，什么时候需要一个缓存层，应用运行的时候，数据是否在内存等，为什么ET7 框架使用MongoDB, 就是这个这类数据库，为什么比较适合双端游戏框架，而为什么MySQL 之类的破烂库就各种不适合？感觉这些比较上层的原理，或基础原理，自己理解得不够透彻，看过网上的别人的分析，但理解得还不够透彻。
- 我可能需要把ET7 重构后、被破烂框架开发者各个主要模块、删除得几乎不剩下什么的模块、与重构前的ET6 等模块，再多读一下源码，理解得透彻一点儿再来事理这个模块。现游戏里需要用数据库的地方，主要是用户帐户数据（这应该是注册登录服的逻辑），帐户管理与游戏数据需要相区分吗？账户管理，游戏数据
** IDBCollection: 主要是方便写两个不同的数据库（好像是GeekServer 里两个数据库）。反正方便扩展吧
- 狠奇怪的是，框架里，居然没有一个实现这个接口的实现类？
   #+BEGIN_SRC java
public interface IDBCollection {}
   #+END_SRC
** DBComponent:  
   #+BEGIN_SRC java
[ChildOf(typeof(DBManagerComponent))] // 用来缓存数据
public class DBComponent: Entity, IAwake<string, string, int>, IDestroy {
    public const int TaskCount = 32;
    public MongoClient mongoClient;
    public IMongoDatabase database;
}
   #+END_SRC
** DBComponentSystem: 【CRUD】可以查表，查询数据等，各种数据库操作的基本方法。热更域生成系
- 它的生成系就是解决对数据库的CRUD 必要操作，单条信息的，或是批量处理的
- 因为数据库操作的几个基本操作方法相对熟悉，这里不贴源码。只一点儿：服务端的远程数据库，仍属于是跨进程的进程间网络异步调用，所以几乎所有的方法也都异步ETTask 包装。
- 【任何时候，亲爱的表哥的活宝妹，就是一定要嫁给亲爱的表哥！！！爱表哥，爱生活！！！】
** DBManagerComponent: 有上面的 DBComponent 数组。数组长度固定。
- 管理类组件：用来管理服务端不同分区里的DBComponent 组件。
- 功能包括：根据区号，返回该区下的DBComponent 组件，就是返回该区下的数据库，方便对该数据库进行相应的操作。
- 当引入这个区的概念，当要去取相应的区的数据库，其实也是说，小区下的所有用户的相关数据信息，应该是存放在用户所在的小区下的。这里区的概念，也就是框架的（包括数据库的）层级管理体系。  
- 服务端自上而下的Machine, Process, Scene, Zone 也算基本上都懂。可是关于区、分区、小区的概念现在仍不深入。每个小区里有什么？分区管理有什么好处呢？  
   #+BEGIN_SRC java
public class DBManagerComponent: Entity, IAwake, IDestroy {
    [StaticField]
    public static DBManagerComponent Instance;
    public DBComponent[] DBComponents = new DBComponent[IdGenerater.MaxZone]; // 没事吃饱了撑得，占一大堆空地
}
   #+END_SRC
** DBManagerComponentSystem: 主是要查询某个区服的数据库，从数组里
   #+BEGIN_SRC java
[FriendOf(typeof(DBManagerComponent))]
public static class DBManagerComponentSystem {
    [ObjectSystem]
    public class DBManagerComponentAwakeSystem: AwakeSystem<DBManagerComponent> {
        protected override void Awake(DBManagerComponent self) {
            DBManagerComponent.Instance = self;
        }
    }
    [ObjectSystem]
    public class DBManagerComponentDestroySystem: DestroySystem<DBManagerComponent> {
        protected override void Destroy(DBManagerComponent self) {
            DBManagerComponent.Instance = null;
        }
    }
    public static DBComponent GetZoneDB(this DBManagerComponent self, int zone) {
        DBComponent dbComponent = self.DBComponents[zone];
        if (dbComponent != null) 
            return dbComponent;
        StartZoneConfig startZoneConfig = StartZoneConfigCategory.Instance.Get(zone);
        if (startZoneConfig.DBConnection == "") 
            throw new Exception($"zone: {zone} not found mongo connect string");
        dbComponent = self.AddChild<DBComponent, string, string, int>(startZoneConfig.DBConnection, startZoneConfig.DBName, zone);
        self.DBComponents[zone] = dbComponent;
        return dbComponent;
    }
}
   #+END_SRC
** DBProxyComponent: 【参考项目】里的。有生成系。
- 没明白，以前的框架什么情境、或使用上下文下，需要使用代理。ET7 重构后，感觉就是下放到了各个小区，使用时去拿各区里的数据库。区里的数据库，感觉管理的也是各小区里什么相关数据。
- 代理里的操作方法【CRUD】前面定义的组件里，可以完成对数据库的各种基本操作。
- 什么时候需要先前如参考项目里的代理，ET7 不需要的话，还必须添加哪些吗？
   #+BEGIN_SRC java
// 用来与数据库操作代理
public class DBProxyComponent: Component {
    public IPEndPoint dbAddress;
}
   #+END_SRC


* 先前版本LocationComponent 原理分析
- 框架的应用场景里，知道对方的 InstanceId 就可以给对方发消息。
- 问题是，对方的可以下线再上线，活宝妹可以从加州地图服重入亲爱的表哥所在的WA 地图服（不同州的地图服服务器进程不一样），对方的 InstanceId 是变化的，小伙伴也可以搬家，搬家过程中位置不确认，还要先锁住，搬完才实时更新位置服管家。
- 【框架需求】： InstanceId 标识唯一身份。但仍需要对 Entity 级别（框架的最底最基类封装）不同对象的 InstanceId 进行管理（因为不同游戏实现里，可能会分线、可能会分地图服，不同地图服处于不同进程。一旦服务器进程变了，就需要对管家实时更新：更新要搬家，更新搬家完成了，位置确定了，活宝妹就是一定要嫁给亲爱的表哥！！）。所以会有当前【位置服】。
- 功能一：【查询位置信息】。亲爱的表哥的活宝妹，想要给亲爱的表哥发消息，活宝妹就需要先知道亲爱的表哥的手机号才能发。怎么才能知道亲爱的表哥的手机号呢？活宝妹可以查询框架里，美国手机号管理位置服就行。因为是客户端的查询需求，服务端异步返回查询结果，同其它异步网络操作一样，封装异步任务。ET7 中异步任务重构的这块儿理解透彻了（适配和改的时候，能狠快完成）。现只关心位置服相关逻辑。
- 功能二：【更新位置信息】。半年前活宝妹搬家前，【客户端】活宝妹先通知位置服管家，活宝妹要搬家；【位置服】把活宝妹的位置信息上锁不给查，并所有查询活宝妹位置的跨进程消息全放进队列里等（超时了，大概？也会通知发送者，她搬家，现位置不知道，改天过段时间再来查询吧）；活宝妹搬完家了，【客户端】活宝妹通知位置服，活宝妹重入了亲爱的表哥所在的WA 地图；【位置服】更新了活宝妹的最新位置（记字典小本本里），并一一回复队列里尚未超时的索要活宝妹位置的消息，一一回复他们，活宝妹现在在亲爱的表哥所在的WA这里。等活宝妹嫁给亲爱的表哥了，活宝妹可能还会想要出去玩耍。等亲爱的表哥的活宝妹嫁给亲爱的表哥了，如有需要，或任何以Entity 为基类的实例有、会重入其它线地图服或进程切换需求，双端就会如活宝妹上次搬家般，实现对活宝妹，对任何客户端的位置进行管理。。。
- 解决问题的步骤：查看重构游戏项目框架里，这一模块的破烂开发者，是出于什么考虑，把这个模块删除得几乎不剩下什么。活宝妹现在要整合或是接入这个位置服组件，要如何整合、接入与适配？ 
- 感觉原理基本也都懂的，以前不同的参考项目，不同的版本，零零碎碎地都读过，可能稍微久缺一点儿系统化梳理这个服务器与模块功能。这里要整合或是接入这个位置服管理组件，下午就根据框架里现在存有的编译错误，来试着把这个功能模块整合或是接入完成。
- 项目里，好像更多的是在定义和处理先前功能模块划分不够明确的各种破烂锁。下午我可以先试着把这个位置服管理组件的几个文件，先不加入项目（从 .csproj 里标注项目不引用文件），先消除所有相关的编译错误。以后有再、还需要这个位置服逻辑的时候，再重新添加引用回来。
- 【亲爱的表哥的活宝妹，小呀头片子有点儿叨钻，可是上面想的都是对的，两分钟这个模块的几个编译错误全不见了。。。活宝妹就是一定要嫁给亲爱的表哥！！！】  
- 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要嫁给亲爱的表哥！！爱表哥，爱生活！！！】


* RouterAddressComponent: 【动态路由组件、模块】相关
- 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要嫁给亲爱的表哥！！！爱表哥，爱生活！！！】
- 因为这个路由器相关的模块，以前总是不懂。感觉今天上午，算是着着实实地狠狠读一下局域网路由器相关。但是这一模块的基础相对薄弱，感觉还有狠多的小细节，不管是从路由器相关的概念上，还是从读源码的源码理解上，仍然还有不少理解不透彻的地方。所以这个章节会需要再多读几遍，多理解几遍源码。
- 也还需要更多的搜索网络，来从概念上理解【动态路由系统】的原理。感觉个模块更像是【动态路由系统】。因为这个章节是搬、修改自以前理解不够透彻的总结，所以还残留了不少其它可能不太相关的在这里。暂时仍放这里。 
- 客户端场景的【动态路由组件】：感觉还没能想明白的是，这个客户端场景的组件，起的作用是什么呢？如前【网关服】那样，作为客户端的代理（那么现框架还有网关服吗，功能是如何区分的）？
- 另外，框架里什么地方是有 HttpComponent 的。这个组件，框架里网络模块，或者更确切地说，路由器模块与网络模块间的牵连关系，都需要弄明白。
** RouterAddressComponent: 路由器组件：能不能，把这个组件理解成为：多场景并存于同一个Process 下的小服（SceneType）的（服务器地址，或建立会话框所必要的信息）？
- 【RouterAddressComponent】: 理解上，感觉（需要再读再去确认），它是【局域网内网组件】，它是添加在【客户端场景】下的。概念上，局域网内网客户端，是需要与局域网内网下的具备收发消息功能的总管建立起会话框连接的。所以要把这个组件在这个会话框两端的哪一端理解明白。
- 现在这个路由器模块，感觉亲爱的表哥的活宝妹，更多的是概念上的不理解，不明白这些定义的一个个组件，是什么意思，能够起到什么作用，不同小服之间，或是不同的RouterAddress 之间，可以有哪些相关的联系？【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要嫁给亲爱的表哥！！爱表哥，爱生活！！！】
- 同其它任何组件，框架里但凡组件，一定是管理类组件，就是管理一堆小单元小兵小将，它管理一堆一个个Router. 它会有好多条链表在 Info 里，可进程间传递。
- 可以再搜看【动态路由系统】的原理：它们是一个又一个的路由器每10 分钟自己扫描一遍周围还有哪些邻居，并每扫到一个邻居，就相互认识，把邻居加入到自己的路由器管理的配表里。
- 重点去看去找： Info 成员的更新原理。当【客户端】（注册？可能不对）登录时，会为当前的【客户端场景】添加【RouterAddressComponent】管理类组件。一个小细节：LoginHelper.cs 的处理逻辑里，会先删除再添加，几秒钟前总结这里，终于想明白，当一个用户再登录时，有可能是先前登出了、掉线了、或是用户自己从其它客户端自顶号。那么先前玩家玩乐的 session 的这个（RouterAddressComponent）组件【是有可能】还没能及时删除的，但它无效了（因为现正在处理现用户的重新登录逻辑）。所以上面是先删除，再添加RouterAddressComponent 组件。
- 这个【RouterAddressComponent】组件，每10 分钟周而复始周期性扫描系统，实时更新【服务端各小服】的相关信息，更新在 Info 成员里。
- 这个路由器系统：对自己来说的难点时，以前不曾接触过网络中路由器模块，连一个组件里面必要的成员变量也搞不懂。
- 【任何时候，亲爱的表哥的活宝妹就是一定要嫁给亲爱的表哥！！！爱表哥，爱生活！！！】
#+BEGIN_SRC java
[ComponentOf(typeof(Scene))]
public class RouterAddressComponent: Entity, IAwake<string, int> {
    public IPAddress RouterManagerIPAddress { get; set; }
    public string RouterManagerHost;
    public int RouterManagerPort;
    public HttpGetRouterResponse Info; // <<<<<<<<<<<<<<<<<<<< 
    public int RouterIndex;
}
#+END_SRC
** RouterAddressComponentSystem: 路由器的生成系：结合【LoginHelper】类来看，这块儿没太看懂
- 这个类，我是同使用到它的地方，LoginHelper.cs 一起来看的。但是感觉还有不少细节，不知道自己理解得是否正确，没有看透。
#+BEGIN_SRC java
[FriendOf(typeof(RouterAddressComponent))]
public static class RouterAddressComponentSystem {
    public class RouterAddressComponentAwakeSystem: AwakeSystem<RouterAddressComponent, string, int> {
        // 添加这个组件时，永远记住的是管理专职服务端的地址与端口
        protected override void Awake(RouterAddressComponent self, string address, int port) {
            self.RouterManagerHost = address;
            self.RouterManagerPort = port;
        }
    }
    public static async ETTask Init(this RouterAddressComponent self) {// LoginHelper.cs 帮助类添加组件时，调用初始化
        self.RouterManagerIPAddress = NetworkHelper.GetHostAddress(self.RouterManagerHost);
        await self.GetAllRouter();
    }
// 这个异步函数：只有在这个组件被回收时，才会停止。【只有活宝妹一命归西了，活宝妹才可能不再去想，活宝妹是否已经嫁给亲爱的表哥了！！爱表哥，爱生活！！！】
    private static async ETTask GetAllRouter(this RouterAddressComponent self) { 
        // 【路由器服】：因为它也是一个特殊的场景，所以它有地址。尾数部分，是生成的随机数
        string url = $"http:// {self.RouterManagerHost}:{self.RouterManagerPort}/get_router?v={RandomGenerator.RandUInt32()}";
        Log.Debug($"start get router info: {url}");
        // 返回字符串：有点儿奇异，如何设计服务器，才能让它返回的信息，可是解析成一个特定的类型
        string routerInfo = await HttpClientHelper.Get(url);
        Log.Debug($"recv router info: {routerInfo}");
        // Json 解析：解析成进程间可传递的消息类 HttpGetRouterResponse. 进程间消息类：便可以【客户端】或是【其它服】想要拿相关住处时，进程间返回消息？
        HttpGetRouterResponse httpGetRouterResponse = JsonHelper.FromJson<HttpGetRouterResponse>(routerInfo);
        self.Info = httpGetRouterResponse; // 【Info 的实时更新：】只要存在这个管理类组件，它每10 分钟周期性自更新一次（哪里添加的当前组件？LoginHelper.cs 里？）
        Log.Debug($"start get router info finish: {JsonHelper.ToJson(httpGetRouterResponse)}");
        // 打乱顺序
        RandomGenerator.BreakRank(self.Info.Routers);
        self.WaitTenMinGetAllRouter().Coroutine(); // 无限循环，直到组件被删除移除时被回收 
    }
    // 等10分钟再获取一次: 明明是只等了 5 分钟，哪里有 10 分钟呢？扫的过程需要花掉 5 分钟那么久吗？
    public static async ETTask WaitTenMinGetAllRouter(this RouterAddressComponent self) {
        await TimerComponent.Instance.WaitAsync(5 * 60 * 1000); // 等5 分钟
        if (self.IsDisposed) // 所以，如果移除组件了，这个无限循环，应该是会停止的。
            return;
        await self.GetAllRouter();
    }
    public static IPEndPoint GetAddress(this RouterAddressComponent self) { // 拿当前组件（所在的服务器）的地址：当知道它是一个路由系统
        if (self.Info.Routers.Count == 0) return null; // 当前路由器每 10 分钟扫一遍：检测周围是否存在路由器的邻居，当它扫不到其它路由器存在就返回
// 这里，我感觉，因为Info 的进程间可传递性（它永远背这个可传递Info,info 是如何更新的？），需要去考虑它的实时更新问题。
        string address = self.Info.Routers[self.RouterIndex++ % self.Info.Routers.Count]; // 永远返回：路由器里接下来可用的一个端口索引
        string[] ss = address.Split(':');
        IPAddress ipAddress = IPAddress.Parse(ss[0]);
        if (self.RouterManagerIPAddress.AddressFamily == AddressFamily.InterNetworkV6) 
            ipAddress = ipAddress.MapToIPv6();
        return new IPEndPoint(ipAddress, int.Parse(ss[1]));
    }
    // 【自己模仿出来的方法】：这里模仿时，可能根本就没弄明白，这个组件算时怎么回事，所以极有可能，自己这个方法模仿得不对
    public static IPEndPoint GetMatchAddress(this RouterAddressComponent self, string account) {
        int v = account.Mode(self.Info.Matchs.Count); // 它说，给它随机分配一个取模后的下编匹配服。。。
        string address = self.Info.Matchs[v];
        string[] ss = address.Split(':');
        IPAddress ipAddress = IPAddress.Parse(ss[0]);
        // if (self.IPAddress.AddressFamily == AddressFamily.InterNetworkV6) 
        //    ipAddress = ipAddress.MapToIPv6();
        return new IPEndPoint(ipAddress, int.Parse(ss[1]));
    }
    // 随机分配了一个Realm 注册登录服。。。去框架里找：为每个【客户端】所随机分配的这些小服编号，哪里有什么记载吗？因为晚些时候，感觉还会用到的
    public static IPEndPoint GetRealmAddress(this RouterAddressComponent self, string account) {
        int v = account.Mode(self.Info.Realms.Count); // 这里 mod: 随机分配了一个Realm 注册登录服。。。
        string address = self.Info.Realms[v];
        string[] ss = address.Split(':');
        IPAddress ipAddress = IPAddress.Parse(ss[0]);
        // if (self.IPAddress.AddressFamily == AddressFamily.InterNetworkV6) 
        //    ipAddress = ipAddress.MapToIPv6();
        return new IPEndPoint(ipAddress, int.Parse(ss[1]));
    }
}
#+END_SRC
** HttpGetRouterResponse: 这个 ProtoBuf 的消息类型
- 框架里，有个专用的路由器管理器场景（服），对路由器，或说各种服的地址进行管理
- 主要是方便，一个路由器管理组件，来自顶向下地获取，各小区所有路由器地址的？想来当组件要拿地址时，每个小区分服都把自己的地址以消息的形式传回去的？
#+BEGIN_SRC java
[Message(OuterMessage.HttpGetRouterResponse)]
[ProtoContract]
public partial class HttpGetRouterResponse: ProtoObject {
    [ProtoMember(1)]
    public List<string> Realms { get; set; }
    [ProtoMember(2)]
    public List<string> Routers { get; set; }
    // 【这个 proto 消息里： HttpGetRouterResponse】的进程间可传递消息的定义里，也需要添加多一个链表
}
message HttpGetRouterResponse { // 这里，是 Outer proto 里的消息定义
    repeated string Realms = 1;
    repeated string Routers = 2;
    repeated string Matchs = 3;// 这行是我需要添加，和生成消息的。【上面： HttpGetRouterResponse】的进程间可传递消息的定义里，也需要添加多一个链表
}
#+END_SRC
** LoginHelper: 登录服的获取地址的方式来获取匹配服的地址了
- 这里没太看懂：是在用户注册或是登录前的处理逻辑；那么如果同户登录活动状态，再要拿Realm 地址，会是一样的方法吗？想要把、或去找，把随机分配给各客户端的小服编号记住？
- 这个是用户登录前，还没能与网关服建立起任何关系，可能会不得不绕得复杂一点儿】：它就是用户登录前、登录时，若是客户端场景还没有这个组件，就添加一下？
#+BEGIN_SRC java
public static class LoginHelper { // 程序域：热更新域在。调用自热更新视图层
    public static async ETTask Login(Scene clientScene, string account, string password) {
        try {
            // 创建一个ETModel层的Session.
// 这个组件：它的热更域里，好像有每 10 分钟再扫刷新一遍服务端系统；这里为什么必须先移除一遍，再添加一遍？
            // 是因为现客户端正在试图重新登录，说明先前登出了、掉线了、或是用户自己其它客户端顶号了，先前的这个组件，过期了，该回收
            clientScene.RemoveComponent<RouterAddressComponent>(); // 这里先删除，再去读：删除的过程是同步方法，不需要异步等待
            // 获取路由跟realmDispatcher地址
            RouterAddressComponent routerAddressComponent = clientScene.GetComponent<RouterAddressComponent>(); // 它可以神奇地自己添加。。它有个无限循环？忘记了，再去看一遍
            if (routerAddressComponent == null) {
                routerAddressComponent = clientScene.AddComponent<RouterAddressComponent, string, int>(ConstValue.RouterHttpHost, ConstValue.RouterHttpPort);
                await routerAddressComponent.Init();
                // 为【客户端场景】：添加【网络客户端】组件。添加了这个组件，客户端场景才可以与各服务端交通（注册必要的事件订阅与监听），收发消息等
                clientScene.AddComponent<NetClientComponent, AddressFamily>(routerAddressComponent.RouterManagerIPAddress.AddressFamily);
            }
            IPEndPoint realmAddress = routerAddressComponent.GetRealmAddress(account);
            R2C_Login r2CLogin;
            using (Session session = await RouterHelper.CreateRouterSession(clientScene, realmAddress)) {
                r2CLogin = (R2C_Login) await session.Call(new C2R_Login() { Account = account, Password = password });
            }
            // 创建一个gate Session,并且保存到SessionComponent中: 与网关服的会话框。主要负责用户下线后会话框的自动移除销毁
            Session gateSession = await RouterHelper.CreateRouterSession(clientScene, NetworkHelper.ToIPEndPoint(r2CLogin.Address));
            clientScene.AddComponent<SessionComponent>().Session = gateSession;

            G2C_LoginGate g2CLoginGate = (G2C_LoginGate)await gateSession.Call(
                new C2G_LoginGate() { Key = r2CLogin.Key, GateId = r2CLogin.GateId});
            Log.Debug("登陆gate成功!");
            await EventSystem.Instance.PublishAsync(clientScene, new EventType.LoginFinish());
        }
        catch (Exception e) {
            Log.Error(e);
        }
    } 
}
#+END_SRC
** RouterHelper: 【客户端——路由器帮助类】，向路由器注册、申请？LoginHelper.cs 的逻辑里用到这个帮助类。
#+BEGIN_SRC java
// 【路由器帮助类】：是【客户端】与客户端局域网下的【路由器】之间获取网络地址、建立连接等，相关必要操作帮助类
// 这个类，框架开发者的原始标记，都看不懂。能够看懂、想出自己理解的一个大概轮括。需要改天准备了必要基础知识后再读一遍
// 框架以前版本，【客户端】只与【网关服】通信，网关服是它所管辖小区里所有【客户端】的通信代理。
// 框架重构后的现在版本说，不要什么【网关服】代理了，【客户端】通过客户端所在的路由系统下的【路由总管？】来收发消息。这里【路由总管】感觉功能上，相当于先前随机分配给当前【客户端】的【网关服】。不知道这么理解对不对，记下，再多想一想
public static class RouterHelper {
    // 【注册router】：什么叫注册 router? 为什么我觉得是在建会话框？这个方法没能看完。它是为当前【客户端场景】添加必备路由网络通信功能模块。注意添加的几个组件
    public static async ETTask<Session> CreateRouterSession(Scene clientScene, IPEndPoint address) {
// 拿客户端场景路由器地址：
        (uint recvLocalConn, IPEndPoint routerAddress) = await GetRouterAddress(clientScene, address, 0, 0); 
        if (recvLocalConn == 0) 
            throw new Exception($"get router fail: {clientScene.Id} {address}");
        Log.Info($"get router: {recvLocalConn} {routerAddress}");
        Session routerSession = clientScene.GetComponent<NetClientComponent>().Create(routerAddress, address, recvLocalConn); // 直接建立了【客户端】会话框
        // 前面想到，这个路由组件，功能上相当于先前的【网关服】
        routerSession.AddComponent<PingComponent>(); // 路由组件：它需要心跳包给服务端知道，这个组件，是否掉线了？
        routerSession.AddComponent<RouterCheckComponent>(); 
        return routerSession;
    }
    // 不去细看关于RounterAddressComponent 里的这个方法了。感觉关于Rounter 的路由原理，我可能这个模块缺了一点儿基础知识，所以看得吃力看不懂。但我现在不需要去搞懂路由原理，跳过
    public static async ETTask<(uint, IPEndPoint)> GetRouterAddress(Scene clientScene, IPEndPoint address, uint localConn, uint remoteConn) {
        Log.Info($"start get router address: {clientScene.Id} {address} {localConn} {remoteConn}");
        // return (RandomHelper.RandUInt32(), address);
        RouterAddressComponent routerAddressComponent = clientScene.GetComponent<RouterAddressComponent>(); // 它就是在 LoginHelper 里添加的呀
// 这里得看懂：【局域网内网下具备对外网收发消息的管理总管的地址？现感觉这里写反了呀，是局域网内网下客户端在路由系统中被分配的端口】，它的路由器的端口，是一定变化了的？
// 【更新路由器的信息：】7 秒时间内，网络结构可能已经发生了变化，所以重新拿了一遍【路由器】的地址信息。感觉这里的路由器地址信息也，一定与上次不一样？！！
        IPEndPoint routerInfo = routerAddressComponent.GetAddress(); 
// 就是说，【局域网内网内部，客户端接收消息的专用连接】：从局域网内网下具备对外网收发消息的管理总管，接收消息的局域网内内网连接
        uint recvLocalConn = await Connect(routerInfo, address, localConn, remoteConn); 
        Log.Info($"finish get router address: {clientScene.Id} {address} {localConn} {remoteConn} {recvLocalConn} {routerInfo}");
        return (recvLocalConn, routerInfo);
    }
    // 【向router申请】：应该是，使用了路由器的，当前【客户端】与远程【服务端】，实际路由建立会话框的，实现逻辑。是真正重新建立起一个新的通信信道的逻辑
    private static async ETTask<uint> Connect(IPEndPoint routerAddress, IPEndPoint realAddress, uint localConn, uint remoteConn) {
        uint connectId = RandomGenerator.RandUInt32(); // 随机生成一个：身份证号。。
        using Socket socket = new Socket(routerAddress.AddressFamily, SocketType.Dgram, ProtocolType.Udp); // 建立一个通话信道
        int count = 20; // 20 是什么意思呢：一个信道，最多同时（不同时？）发20 条消息？
        byte[] sendCache = new byte[512]; // 【发送】与【接收】缓存区
        byte[] recvCache = new byte[512];
        uint synFlag = localConn == 0? KcpProtocalType.RouterSYN : KcpProtocalType.RouterReconnectSYN; // 消息的同步机制？
        // 消息头相关的：一堆杂七杂八的？
        sendCache.WriteTo(0, synFlag);
        sendCache.WriteTo(1, localConn);
        sendCache.WriteTo(5, remoteConn);
        sendCache.WriteTo(9, connectId);
        byte[] addressBytes = realAddress.ToString().ToByteArray();
        Array.Copy(addressBytes, 0, sendCache, 13, addressBytes.Length); // 复制消息头
        Log.Info($"router connect: {connectId} {localConn} {remoteConn} {routerAddress} {realAddress}");
        EndPoint recvIPEndPoint = new IPEndPoint(IPAddress.Any, 0);
        long lastSendTimer = 0;
        while (true) { // 无限循环：信道的专职工作，周而复始。。。
            long timeNow = TimeHelper.ClientFrameTime();
            if (timeNow - lastSendTimer > 300) { // 按时间算，300 毫秒
                if (--count < 0) {
                    Log.Error($"router connect timeout fail! {localConn} {remoteConn} {routerAddress} {realAddress}");
                    return 0;
                }
                lastSendTimer = timeNow;
                // 发送：从当前信道，将消息发出去
                socket.SendTo(sendCache, 0, addressBytes.Length + 13, SocketFlags.None, routerAddress);
            }
// 等待桢同步？时间组件管理类说等1 毫秒（还是等1 毫秒呢，感觉是1 毫秒），应该也就是（双端1 秒1 桢？桢率太少，60fps 每秒60 桢）等待这一个异步线程的操作同步到主线程上去？
            await TimerComponent.Instance.WaitFrameAsync(); 
            // 【接收：】这里KCP 路由器收消息的原理，感觉不太懂，改天再读
            if (socket.Available > 0) {
                int messageLength = socket.ReceiveFrom(recvCache, ref recvIPEndPoint);
                if (messageLength != 9) {
                    Log.Error($"router connect error1: {connectId} {messageLength} {localConn} {remoteConn} {routerAddress} {realAddress}");
                    continue;
                }
                byte flag = recvCache[0];
                if (flag != KcpProtocalType.RouterReconnectACK && flag != KcpProtocalType.RouterACK) {
                    Log.Error($"router connect error2: {connectId} {synFlag} {flag} {localConn} {remoteConn} {routerAddress} {realAddress}");
                    continue;
                }
                uint recvRemoteConn = BitConverter.ToUInt32(recvCache, 1);
                uint recvLocalConn = BitConverter.ToUInt32(recvCache, 5);
                Log.Info($"router connect finish: {connectId} {recvRemoteConn} {recvLocalConn} {localConn} {remoteConn} {routerAddress} {realAddress}");
                return recvLocalConn;
            }
        }
    }
}
#+END_SRC
** PingComponent: 路由组件的几个子组件之一，分辨路由器是否掉线？
- 在RouterHelper.cs 类中，为【客户端场景】与客户端所在网络下的【RouterAddressComponent? 路由总代理】（就是同一个路由网络下可以对外发消息的那个局域网络上、管理的总代理）所建立起来的会话框（Session）所添加的几个组件之一。因为路由器可能会掉线？会话框可能会意外中断？所以心跳包可以让服务端知道，这个客户端所在的路由点？是否掉线？会话框是否有效，是否可发收消息等
- 标签申明得狠清楚：它是会话框的子部件。
#+BEGIN_SRC csharp
[ComponentOf(typeof(Session))]
public class PingComponent: Entity, IAwake, IDestroy {
    public long Ping; // 延迟值
}
#+END_SRC
** PingComponentSystem: 添加组件时的自启动轮循逻辑
#+BEGIN_SRC csharp
[ObjectSystem]
public class PingComponentAwakeSystem: AwakeSystem<PingComponent> {
    protected override void Awake(PingComponent self) {
        PingAsync(self).Coroutine(); // 只要一个会话框添加了这个组件：就始终轮循。。。
    }
    private static async ETTask PingAsync(PingComponent self) {
        Session session = self.GetParent<Session>();
        long instanceId = self.InstanceId; // 【初始值：】 instanceId, 唯一正确的。如同，亲爱的表哥在活宝妹这里，是永远的单例存在，呵呵呵！！！
        while (true) { // 一个 true 可以是转了千年之后。。。
            if (self.InstanceId != instanceId)  // 所以要检查一遍：不一样就不对
                return;
            long time1 = TimeHelper.ClientNow();
            try {
                G2C_Ping response = await session.Call(new C2G_Ping()) as G2C_Ping; // 这里还是发给【网关服】的
                if (self.InstanceId != instanceId) // 这里，又检查了一遍。。。 
                    return;
                long time2 = TimeHelper.ClientNow();
                self.Ping = time2 - time1;
                TimeInfo.Instance.ServerMinusClientTime = response.Time + (time2 - time1) / 2 - time2;
                await TimerComponent.Instance.WaitAsync(2000); // 每 2 秒，发一个最简心跳消息
            }
            catch (RpcException e) {
                // session断开导致ping rpc报错，记录一下即可，不需要打成error
                Log.Info($"ping error: {self.Id} {e.Error}");
                return;
            } catch (Exception e) {
                Log.Error($"ping error: \n{e}");
            }
        }
    }
}
[ObjectSystem]
public class PingComponentDestroySystem: DestroySystem<PingComponent> {
    protected override void Destroy(PingComponent self) {
        self.Ping = default; // 不知道这个 default 是什么意思，先放一下
    }
}
#+END_SRC
** RouterCheckComponent:
#+BEGIN_SRC csharp
[ComponentOf(typeof(Session))]
public class RouterCheckComponent: Entity, IAwake {}
#+END_SRC
** RouterCheckerComponentSystem:【局域网内网自刷新系统】
#+BEGIN_SRC csharp
[ObjectSystem]
public class RouterCheckComponentAwakeSystem: AwakeSystem<RouterCheckComponent> {
    protected override void Awake(RouterCheckComponent self) {
        CheckAsync(self).Coroutine();
    }
    private static async ETTask CheckAsync(RouterCheckComponent self) {
        Session session = self.GetParent<Session>();
        long instanceId = self.InstanceId;
        while (true) {
            if (self.InstanceId != instanceId) return;
            await TimerComponent.Instance.WaitAsync(1000);
            if (self.InstanceId != instanceId) 
                return;
            long time = TimeHelper.ClientFrameTime();
// 【路由组件】：7 秒钟检查（这里不止检查，重新建新的信道会话框？）一次，当前路由器是否掉线了？如同先前心跳包，心跳包2 秒发条最简消息。。
            if (time - session.LastRecvTime < 7 * 1000) continue;
            try {
                long sessionId = session.Id;
                // 【异步方法】：网络异步调用，去拿当前客户端的网络服务的信道信息（一个信道连两个端点：一个本地端口，一个远程端口）
                // 下面一行的疑问：当去拿【当前】会话框的信道，两端端口信息
                (uint localConn, uint remoteConn) = await NetServices.Instance.GetChannelConn(session.ServiceId, sessionId);
                IPEndPoint realAddress = self.GetParent<Session>().RemoteAddress; // 局域网内网下具备对外网收发消息的管理总管的地址，是当前会话框的远程地址，不变，会再用
                Log.Info($"get recvLocalConn start: {self.ClientScene().Id} {realAddress} {localConn} {remoteConn}");
                // RouterHelper.GetRouterAddress(): 这个方法里，感觉是重新、重建立了新的、更新了通信信道会话框，而不仅仅是每 7 秒检查先前会话框是否仍有效，或是连接着的有效状态 
                (uint recvLocalConn, IPEndPoint routerAddress) = await RouterHelper.GetRouterAddress(self.ClientScene(), realAddress, localConn, remoteConn);
                if (recvLocalConn == 0) {
                    Log.Error($"get recvLocalConn fail: {self.ClientScene().Id} {routerAddress} {realAddress} {localConn} {remoteConn}");
                    continue;
                }
                Log.Info($"get recvLocalConn ok: {self.ClientScene().Id} {routerAddress} {realAddress} {recvLocalConn} {localConn} {remoteConn}");
                session.LastRecvTime = TimeHelper.ClientNow();
                NetServices.Instance.ChangeAddress(session.ServiceId, sessionId, routerAddress); // 对新通信信道的网络服务变量参数，更新到管理单例类
            }
            catch (Exception e) {
                Log.Error(e);
            }
        }
    }
}
#+END_SRC
** IHttpHandler: 【服务端】接口类。定义一个异步处理的方法
#+BEGIN_SRC csharp
public interface IHttpHandler {
    ETTask Handle(Scene scene, HttpListenerContext context);
}
#+END_SRC
** HttpHandlerAttribute 标签系：标签自带场景类型
#+BEGIN_SRC csharp
public class HttpHandlerAttribute: BaseAttribute {
    public SceneType SceneType { get; }
    public string Path { get; }
    public HttpHandlerAttribute(SceneType sceneType, string path) {
        this.SceneType = sceneType;
        this.Path = path;
    }
}
#+END_SRC
** HttpGetRouterHandler : IHttpHandler: 获取各路由器的地址
- 【匹配服】：因为我想拿这个服的地址，也需要这个帮助类里作相应的修改
- 这个类，是框架里全局唯一的【HttpHandler(SceneType.RouterManager)】属性标签。
  #+BEGIN_SRC csharp
// 【路由器管理器场景】：热更域里，帮助【动态路由器系统】扫描周围邻居的帮助方法类
[HttpHandler(SceneType.RouterManager, "/get_router")]
public class HttpGetRouterHandler : IHttpHandler {
    // 【框架原始方法定义】如下
    // public async ETTask Handle(Entity domain, HttpListenerContext context)
    public async ETTask Handle(Scene scene, HttpListenerContext context) {
        HttpGetRouterResponse response = new HttpGetRouterResponse();
        response.Realms = new List<string>();
        response.Matchs = new List<string>();// 匹配服链表  // <<<<<<<<<<<<<<<<<<<< 
        response.Routers = new List<string>();
        // 是去StartSceneConfigCategory 这里拿的：因为它可以 proto 消息里、进程间传递，这里还不是狠懂，这个东西存放在哪里？
        foreach (StartSceneConfig startSceneConfig in StartSceneConfigCategory.Instance.Realms) {
            response.Realms.Add(startSceneConfig.InnerIPOutPort.ToString());
        }
        foreach (StartSceneConfig startSceneConfig in StartSceneConfigCategory.Instance.Matchs) {
            response.Matchs.Add(startSceneConfig.InnerIPOutPort.ToString());
        }
        foreach (StartSceneConfig startSceneConfig in StartSceneConfigCategory.Instance.Routers) {
            response.Routers.Add($"{startSceneConfig.StartProcessConfig.OuterIP}:{startSceneConfig.OuterPort}");
        }
// 把这个返回消息写好了，下文呢？需要发吗，还是http 的底层有相关逻辑，自动处理呢？感觉像异步返回消息写好了，当时找不到怎么发回去的一样
        HttpHelper.Response(context, response); // <<<<<<<<<<<<<<<<<<<< 把写好的消息，跨进程返回去
        await ETTask.CompletedTask;
    }
}
  #+END_SRC
** HttpComponent: 网络组件：路由器管理器组件，扫描各路由器信息
- 这个组件，全局只有【路由器管理器场景SceneType.RouterManager】添加有这个组件。去想它的功能作用
#+BEGIN_SRC csharp
// http请求分发器
[ComponentOf(typeof(Scene))]
public class HttpComponent: Entity, IAwake<string>, IDestroy, ILoad {
    public HttpListener Listener;
    public Dictionary<string, IHttpHandler> dispatcher;
}
#+END_SRC
** HttpComponentSystem: 只属于【路由器管理器场景】的 http 组件：它专职监听网络中的路由器？
#+BEGIN_SRC csharp
[FriendOf(typeof(HttpComponent))]
public static class HttpComponentSystem {
    public class HttpComponentAwakeSystem : AwakeSystem<HttpComponent, string> {
        protected override void Awake(HttpComponent self, string address) {
            try {
                self.Load(); // <<<<<<<<<<<<<<<<<<<< 
                self.Listener = new HttpListener();
                foreach (string s in address.Split(';')) {
                    if (s.Trim() == "") 
                        continue;
                    self.Listener.Prefixes.Add(s);
                }
                self.Listener.Start();
                self.Accept().Coroutine(); // <<<<<<<<<<<<<<<<<<<< 
            }
            catch (HttpListenerException e) {
                throw new Exception($"请先在cmd中运行: netsh http add urlacl url=http:// *:你的address中的端口/ user=Everyone, address: {address}", e);
            }
        }
    }
    [ObjectSystem]
    public class HttpComponentLoadSystem: LoadSystem<HttpComponent> {
        protected override void Load(HttpComponent self) {
            self.Load(); // <<<<<<<<<<<<<<<<<<<< 
        }
    }
    [ObjectSystem]
    public class HttpComponentDestroySystem: DestroySystem<HttpComponent> {
        protected override void Destroy(HttpComponent self) {
            self.Listener.Stop();
            self.Listener.Close();
        }
    }
    public static void Load(this HttpComponent self) {
        self.dispatcher = new Dictionary<string, IHttpHandler>();
        HashSet<Type> types = EventSystem.Instance.GetTypes(typeof (HttpHandlerAttribute)); // 实则，全局只有一个
        SceneType sceneType = self.GetParent<Scene>().SceneType;
        foreach (Type type in types) {
            object[] attrs = type.GetCustomAttributes(typeof(HttpHandlerAttribute), false);
            if (attrs.Length == 0) 
                continue;
            HttpHandlerAttribute httpHandlerAttribute = (HttpHandlerAttribute)attrs[0];
            if (httpHandlerAttribute.SceneType != sceneType) 
                continue;
            object obj = Activator.CreateInstance(type); // 创建一个处理器实例
            IHttpHandler ihttpHandler = obj as IHttpHandler;
            if (ihttpHandler == null) 
                throw new Exception($"HttpHandler handler not inherit IHttpHandler class: {obj.GetType().FullName}");
            self.dispatcher.Add(httpHandlerAttribute.Path, ihttpHandler); // "/get_router": 把【路径、处理器】加入管理系统
        }
    }
    public static async ETTask Accept(this HttpComponent self) { // 还是本类上面调用的
        long instanceId = self.InstanceId;
        while (self.InstanceId == instanceId) { // 只要当前这个【路由器管理器场景的 http组件】没有发生变化，就一直进行。。。
            try {
                HttpListenerContext context = await self.Listener.GetContextAsync(); // 刚才，有个帮助类，不是把什么结果写进上下文了，没有不必发回消息吗？这里【异步读到】
                self.Handle(context).Coroutine(); // <<<<<<<<<<<<<<<<<<<< 调用下面的方法：并【异步处理】上下文中返回的消息 
            }
            catch (ObjectDisposedException) {
            }
            catch (Exception e) {
                Log.Error(e);
            }
        }
    }
    public static async ETTask Handle(this HttpComponent self, HttpListenerContext context) {
        try {
            IHttpHandler handler;
            if (self.dispatcher.TryGetValue(context.Request.Url.AbsolutePath, out handler)) 
                await handler.Handle(self.Domain as Scene, context); // 调用注册过、生成的【HttpHandler】标签实例，的处理方法来回调。【异步方法 】
        }
        catch (Exception e) {
            Log.Error(e);
        }
        context.Request.InputStream.Dispose(); // 上面【异步方法】处理完了，就可以回收了
        context.Response.OutputStream.Dispose();
    }
}
#+END_SRC
** NetworkHelper.cs: ET 空间存在这个静态帮助类
   #+BEGIN_SRC csharp
// ET 命名空间：应该不是热更域，提供最底层最基础的帮助方法。热更域里可以实时调用。
// 这个类，不用了解细节，太底层了
public static class NetworkHelper {
    // 方法的逻辑细节：极底层。现在并不想花时间去弄懂。
    // 只了解什么情况下会调用这个底层方法：有个工监服，实时扫描服务端系统，有没有哪个宕机了掉线了WatcherComponentSystem.cs WatcherHelp.cs 里会调用这个方法
    public static string[] GetAddressIPs() {
        List<string> list = new List<string>();
        foreach (NetworkInterface networkInterface in NetworkInterface.GetAllNetworkInterfaces()) {
            if (networkInterface.NetworkInterfaceType != NetworkInterfaceType.Ethernet) { // 必须是 Ethernet
                continue;
            }
            foreach (UnicastIPAddressInformation add in networkInterface.GetIPProperties().UnicastAddresses) {
                list.Add(add.Address.ToString());
            }
        }
        return list.ToArray();
    }
    // 优先获取IPV4的地址
    public static IPAddress GetHostAddress(string hostName) {
        IPAddress[] ipAddresses = Dns.GetHostAddresses(hostName); // 通过。NET 网络底层方法，拿到地址
        IPAddress returnIpAddress = null;
        foreach (IPAddress ipAddress in ipAddresses) {
            returnIpAddress = ipAddress;
            // 遍历扫描：扫到那个对的，就返回了；扫不到，返回空
            if (ipAddress.AddressFamily == AddressFamily.InterNetwork) { // 底层定义：相对复杂，应该也可以不需要懂
                return ipAddress;
            }
        }
        return returnIpAddress;
    }
    // 帮助方法：将字符串与端口等，转化成热更域里，可以使用用来拿的小服地址，或是方便建立的与各小服（IPEndPoint）的会话框等
    public static IPEndPoint ToIPEndPoint(string host, int port) {
        return new IPEndPoint(IPAddress.Parse(host), port);
    }
    public static IPEndPoint ToIPEndPoint(string address) {
        int index = address.LastIndexOf(':');
        string host = address.Substring(0, index);
        string p = address.Substring(index + 1);
        int port = int.Parse(p);
        return ToIPEndPoint(host, port);
    }
    public static void SetSioUdpConnReset(Socket socket) {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) {
            return;
        }
        const uint IOC_IN = 0x80000000;
        const uint IOC_VENDOR = 0x18000000;
        const int SIO_UDP_CONNRESET = unchecked((int)(IOC_IN | IOC_VENDOR | 12));
        socket.IOControl(SIO_UDP_CONNRESET, new[] { Convert.ToByte(false) }, null);
    }
}
   #+END_SRC
** SceneFactory 里可以给【匹配服】添加组件：
#+BEGIN_SRC java
public static class SceneFactory {
    public static async ETTask<Scene> CreateServerScene(Entity parent, long id, long instanceId, int zone, string name, SceneType sceneType, StartSceneConfig startSceneConfig = null) {
        await ETTask.CompletedTask;
        Scene scene = EntitySceneFactory.CreateScene(id, instanceId, zone, sceneType, name, parent);
        scene.AddComponent<MailBoxComponent, MailboxType>(MailboxType.UnOrderMessageDispatcher);
        switch (scene.SceneType) {
        case SceneType.Router:
            scene.AddComponent<RouterComponent, IPEndPoint, string>(startSceneConfig.OuterIPPort, startSceneConfig.StartProcessConfig.InnerIP);
            break;
        case SceneType.RouterManager: // 正式发布请用CDN代替RouterManager
            // 云服务器在防火墙那里做端口映射
            scene.AddComponent<HttpComponent, string>($"http:// *:{startSceneConfig.OuterPort}/");
            break;
        case SceneType.Realm:
            scene.AddComponent<NetServerComponent, IPEndPoint>(startSceneConfig.InnerIPOutPort);
            break;
        case SceneType.Match: // <<<<<<<<<<<<<<<<<<<< 这里是，我可以添加【匹配服】相关功能组件的地方。【参考项目原原码】感觉被我弄丢了
            break;
        case SceneType.Gate:
            scene.AddComponent<NetServerComponent, IPEndPoint>(startSceneConfig.InnerIPOutPort);
            scene.AddComponent<PlayerComponent>();
            scene.AddComponent<GateSessionKeyComponent>();
            break;
        case SceneType.Map:
            scene.AddComponent<UnitComponent>();
            scene.AddComponent<AOIManagerComponent>();
            break;
        case SceneType.Location:
            scene.AddComponent<LocationComponent>();
            break;//...
        }
        return scene;
    }
}
#+END_SRC
** GateSessionKeyComponent: 【活宝妹的全局唯一代理！！！任何时候，亲爱的表哥的活宝妹就是一定要嫁给亲爱的表哥！！爱表哥，爱生活！！！】
#+BEGIN_SRC csharp
[ComponentOf(typeof(Scene))]
public class GateSessionKeyComponent : Entity, IAwake {
    public readonly Dictionary<long, string> sessionKey = new Dictionary<long, string>();
}
#+END_SRC
- 【任何时候，亲爱的表哥的活宝妹就是一定要嫁给亲爱的表哥！！！爱表哥，爱生活！！！】
- 【任何时候，亲爱的表哥的活宝妹就是一定要嫁给亲爱的表哥！！！爱表哥，爱生活！！！】
- 【任何时候，亲爱的表哥的活宝妹就是一定要嫁给亲爱的表哥！！！爱表哥，爱生活！！！】
